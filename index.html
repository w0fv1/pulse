<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP接口健康监控</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.12.24/dist/full.min.css" rel="stylesheet" type="text/css"/>
    <script src="https://cdn.tailwindcss.com/3.4.16"></script> <!-- 使用较新版 Tailwind -->
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <!-- 确保 Alpine 在 SweetAlert 和 Tailwind 之后加载 -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.14.9/dist/cdn.min.js"></script>
    <style>
        /* 隐藏未初始化的 Alpine 元素，防止闪烁 */
        [x-cloak] {
            display: none !important;
        }

        /* Favicon 图片样式 */
        .favicon-img {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            flex-shrink: 0;
            object-fit: contain;
        }

        /* 日志模态框内容区域样式 */
        .log-modal-content {
            max-height: 60vh;
            overflow-y: auto;
        }

        /* 卡片底部按钮间距 */
        .card-actions .btn {
            margin-left: 0.25rem;
        }

        /* 卡片标题区域布局 */
        .card-title-area {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 4px;
        }

        /* 覆盖 daisyUI 默认的卡片标题下边距 */
        .card-title-area .card-title {
            margin-bottom: 0;
        }

        /* 防止按钮组换行 */
        .card-title-area .btn-group {
            flex-shrink: 0;
        }
    </style>
</head>

<body class="bg-base-200 text-base-content min-h-screen" x-data="appState()" x-init="init()" x-cloak>

<!-- Navbar 导航栏 -->
<div class="navbar bg-primary text-primary-content shadow-md sticky top-0 z-50">
    <div class="flex-1">
        <a class="btn btn-ghost text-xl">接口健康监控</a>
    </div>
    <div class="flex-none gap-2">
        <!-- 导入/导出 按钮组 -->
        <div class="dropdown dropdown-end">
            <button tabindex="0" role="button" class="btn btn-ghost">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                     stroke="currentColor" class="w-5 h-5 mr-1">
                    <path stroke-linecap="round" stroke-linejoin="round"
                          d="M12 10.5v6m3-3H9m4.06-7.19-2.12-2.12a1.5 1.5 0 0 0-1.061-.44H4.5A2.25 2.25 0 0 0 2.25 6v12a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18V9a2.25 2.25 0 0 0-2.25-2.25h-5.379a1.5 1.5 0 0 1-1.06-.44Z"/>
                </svg>
                管理
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                     stroke="currentColor" class="w-4 h-4 ml-1">
                    <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5"/>
                </svg>
            </button>
            <ul tabindex="0"
                class="dropdown-content z-[1] menu p-2 shadow bg-base-100 rounded-box w-52 text-base-content">
                <li><a @click="importConfigTrigger()">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                         stroke="currentColor" class="w-4 h-4 mr-2">
                        <path stroke-linecap="round" stroke-linejoin="round"
                              d="M9 8.25H7.5a2.25 2.25 0 0 0-2.25 2.25v9a2.25 2.25 0 0 0 2.25 2.25h9a2.25 2.25 0 0 0 2.25-2.25v-9a2.25 2.25 0 0 0-2.25-2.25H15M9 12l3 3m0 0 3-3m-3 3V2.25"/>
                    </svg>
                    导入配置 (文件)</a></li>
                <li><a @click="openTextImportModal()">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                         stroke="currentColor" class="w-4 h-4 mr-2">
                        <path stroke-linecap="round" stroke-linejoin="round"
                              d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L6.832 19.82a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.863 4.487zm0 0L19.5 7.125"/>
                    </svg>
                    导入配置 (文本)</a></li>
                <li><a @click="exportConfig()">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                         stroke="currentColor" class="w-4 h-4 mr-2">
                        <path stroke-linecap="round" stroke-linejoin="round"
                              d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"/>
                    </svg>
                    导出配置 (.json)</a></li>
            </ul>
        </div>
        <!-- 新增接口 按钮 -->
        <button class="btn btn-accent" @click="openAddModal()">+ 新增接口</button>
        <!-- 隐藏的文件输入框，用于点击触发导入 -->
        <input type="file" class="hidden" x-ref="fileInput" @change="handleFileImport($event)" accept=".json">
    </div>
</div>

<!-- 主内容区域: 接口卡片网格 + 拖拽导入区域 -->
<main class="p-4 md:p-6 transition-colors duration-200 relative min-h-[calc(100vh-10rem)]"
      :class="{ 'bg-primary/10 border-2 border-dashed border-primary': isDraggingOver }"
      @dragover.prevent="isDraggingOver = true" @dragleave.prevent="isDraggingOver = false"
      @drop.prevent="handleFileDrop($event)">
    <!-- 可选: 拖拽时的视觉提示遮罩层 -->
    <div x-show="isDraggingOver"
         class="absolute inset-0 flex items-center justify-center text-primary font-semibold text-lg pointer-events-none z-10">
        拖拽 .json 文件到此处导入
    </div>

    <!-- 卡片网格 -->
    <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 md:gap-6 relative z-0"
         :class="{ 'opacity-50': isDraggingOver }">

        <!-- 卡片模板 (循环渲染接口) -->
        <template x-for="iface in interfaces" :key="iface.id">
            <div class="card bg-base-100 shadow-xl border-t-4 min-h-[210px] flex flex-col justify-between"
                 :class="{ 'border-success': iface.status === 'ok', 'border-error': iface.status === 'error', 'border-warning': iface.status === 'pending', 'border-base-300': !iface.status }">
                <div class="card-body p-4">
                    <div class="card-title-area mb-2">
                        <div class="flex items-center min-w-0 flex-1"><img
                                :src="iface.favicon || DEFAULT_FAVICON_URI"
                                @error="if (event.target.src !== DEFAULT_FAVICON_URI) event.target.src = DEFAULT_FAVICON_URI"
                                alt="favicon" class="favicon-img">
                            <h2 class="card-title text-lg truncate" x-text="iface.title" :title="iface.title"></h2>
                        </div>
                        <div class="btn-group">
                            <button @click="openEditModal(iface)"
                                    class="btn btn-xs btn-ghost text-info hover:bg-info/10 p-1" title="编辑接口">
                                <svg
                                        xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="16" height="16"
                                        viewBox="0 0 24 24">
                                    <path
                                            d="M10 21H5C3.89 21 3 20.11 3 19V5C3 3.89 3.89 3 5 3H19C20.11 3 21 3.89 21 5V10.33C20.7 10.21 20.37 10.14 20.04 10.14C19.67 10.14 19.32 10.22 19 10.37V5H5V19H10.11L10 19.11V21M7 9H17V7H7V9M7 17H12.11L14 15.12V15H7V17M7 13H16.12L17 12.12V11H7V13M21.7 13.58L20.42 12.3C20.21 12.09 19.86 12.09 19.65 12.3L18.65 13.3L20.7 15.35L21.7 14.35C21.91 14.14 21.91 13.79 21.7 13.58M12 22H14.06L20.11 15.93L18.06 13.88L12 19.94V22Z"/>
                                </svg>
                            </button>
                            <button @click="confirmDeleteInterface(iface.id)"
                                    class="btn btn-xs btn-ghost text-error hover:bg-error/10 p-1" title="删除接口">
                                <svg
                                        xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="16" height="16"
                                        viewBox="0 0 24 24">
                                    <path
                                            d="M9,3V4H4V6H5V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V6H20V4H15V3H9M7,6H17V19H7V6M9,8V17H11V8H9M13,8V17H15V8H13Z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <p class="text-xs text-base-content/70 break-all mb-2" :title="iface.url"
                       x-text="truncateUrl(iface.url)"></p>
                    <div class="flex items-center text-sm mb-1">
                            <span class="mr-1 text-xl"
                                  :class="{ 'text-success': iface.status === 'ok', 'text-error': iface.status === 'error', 'text-warning': iface.status === 'pending', 'text-base-content/50': !iface.status }"><span
                                    x-show="iface.status === 'ok'">✅</span><span
                                    x-show="iface.status === 'error'">❌</span><span
                                    x-show="iface.status === 'pending'"><span
                                    class="loading loading-spinner loading-xs"></span></span><span
                                    x-show="!iface.status">-</span></span>
                        <span class="font-medium"
                              :class="{ 'text-success': iface.status === 'ok', 'text-error': iface.status === 'error', 'text-warning': iface.status === 'pending', 'text-base-content/70': !iface.status }"><span
                                x-text="getStatusText(iface.status)"></span><span
                                x-show="iface.status === 'ok' && iface.lastResponseTime !== undefined"
                                x-text="' (' + iface.lastResponseTime + 'ms)'"></span></span>
                    </div>
                    <p class="text-xs text-error" x-show="iface.status === 'error' && iface.lastError"
                       x-text="'原因: ' + iface.lastError"></p>
                    <p class="text-xs text-base-content/50 mt-1" x-show="iface.lastChecked"
                       x-text="'上次检测: ' + formatTimestamp(iface.lastChecked)"></p>
                    <p class="text-xs text-base-content/50 mt-1"
                       x-show="iface.lastChecked && iface.status !== 'pending' && iface.nextCheckInSeconds !== undefined"
                       x-text="'下次检测: ' + (iface.nextCheckInSeconds > 0 ? iface.nextCheckInSeconds + ' 秒后' : '即将进行...')">
                    </p>
                </div>
                <div class="card-actions justify-end p-4 pt-0">
                    <button class="btn btn-sm btn-outline btn-info"
                            @click="openLogModal(iface.id)">查看日志
                    </button>
                </div>
            </div>
        </template> <!-- 卡片模板结束 -->

        <!-- 空状态占位符: 仅在没有接口且没有拖拽悬浮时显示 -->
        <div x-show="interfaces.length === 0 && !isDraggingOver"
             class="col-span-full text-center py-10 text-base-content/70">
            <div class="card bg-base-100 shadow-md p-6 inline-block">
                <p class="mb-4">还没有监控任何接口。</p>
                <div class="flex gap-2 justify-center">
                    <button @click="openAddModal()" class="btn btn-primary">点击添加第一个</button>
                    <button @click="importConfigTrigger()" class="btn btn-secondary">或导入配置</button>
                </div>
            </div>
        </div>

    </div> <!-- 网格结束 -->
</main>

<!-- Add Interface Modal 新增接口模态框 -->
<dialog id="addInterfaceModal" class="modal" x-ref="addModal">
    <div class="modal-box">
        <h3 class="font-bold text-lg mb-4">新增监控接口</h3>
        <form @submit.prevent="addInterface()">
            <div class="form-control w-full mb-4"><label class="label"><span class="label-text">接口标题 <span
                    class="text-error">*</span></span></label><input type="text"
                                                                     x-model="newInterface.title" required
                                                                     placeholder="例如：用户API状态"
                                                                     class="input input-bordered w-full"/></div>
            <div class="form-control w-full mb-4"><label class="label"><span class="label-text">接口 URL <span
                    class="text-error">*</span> (http/https)</span></label><input type="text"
                                                                                  x-model="newInterface.url" required
                                                                                  pattern="^(https?|http)://.+"
                                                                                  placeholder="https://example.com/api/status"
                                                                                  class="input input-bordered w-full"/>
            </div>
            <div class="form-control w-full mb-4"><label class="label"><span class="label-text">预期返回包含字符 <span
                    class="text-error">*</span></span></label><input type="text"
                                                                     x-model="newInterface.expectedText" required
                                                                     placeholder='例如: success, "status":"ok"'
                                                                     class="input input-bordered w-full"/></div>
            <div class="form-control w-full mb-4"><label class="label"><span class="label-text">超时时间 (秒,
                            默认3)</span></label><input type="number" x-model.number="newInterface.timeout" min="1"
                                                        placeholder="3" class="input input-bordered w-full"/></div>
            <div class="modal-action">
                <button type="button" class="btn btn-ghost"
                        @click="closeAddModal()">取消
                </button>
                <button type="submit" class="btn btn-primary">确认添加</button>
            </div>
        </form>
    </div>
    <div class="modal-backdrop">
        <button @click.prevent="closeAddModal()">close</button>
    </div>
</dialog>

<!-- Edit Interface Modal 编辑接口模态框 -->
<dialog id="editInterfaceModal" class="modal" x-ref="editModal">
    <div class="modal-box">
        <template x-if="editingInterface">
            <div>
                <h3 class="font-bold text-lg mb-4">编辑监控接口</h3>
                <form @submit.prevent="updateInterface()">
                    <div class="form-control w-full mb-4"><label class="label"><span class="label-text">接口标题 <span
                            class="text-error">*</span></span></label><input type="text"
                                                                             x-model="editingInterface.title" required
                                                                             placeholder="例如：用户API状态"
                                                                             class="input input-bordered w-full"/></div>
                    <div class="form-control w-full mb-4"><label class="label"><span class="label-text">接口 URL <span
                            class="text-error">*</span> (http/https)</span></label><input type="text"
                                                                                          x-model="editingInterface.url"
                                                                                          required
                                                                                          pattern="^(https?|http)://.+"
                                                                                          placeholder="https://example.com/api/status"
                                                                                          class="input input-bordered w-full"/>
                    </div>
                    <div class="form-control w-full mb-4"><label class="label"><span class="label-text">预期返回包含字符
                                    <span class="text-error">*</span></span></label><input type="text"
                                                                                           x-model="editingInterface.expectedText"
                                                                                           required
                                                                                           placeholder='例如: success, "status":"ok"'
                                                                                           class="input input-bordered w-full"/>
                    </div>
                    <div class="form-control w-full mb-4"><label class="label"><span class="label-text">超时时间
                                    (秒)</span></label><input type="number" x-model.number="editingInterface.timeout"
                                                              min="1" placeholder="3"
                                                              class="input input-bordered w-full"/></div>
                    <div class="modal-action">
                        <button type="button" class="btn btn-ghost"
                                @click="closeEditModal()">取消
                        </button>
                        <button type="submit"
                                class="btn btn-primary">保存更改
                        </button>
                    </div>
                </form>
            </div>
        </template>
        <div x-show="!editingInterface" class="text-center p-4"></div>
    </div>
    <div class="modal-backdrop">
        <button @click.prevent="closeEditModal()">close</button>
    </div>
</dialog>

<!-- Log Viewer Modal 日志查看模态框 -->
<dialog id="logModal" class="modal" x-ref="logModal">
    <div class="modal-box w-11/12 max-w-5xl">
        <div class="flex justify-between items-center mb-4">
            <h3 class="font-bold text-lg">接口日志: <span x-text="getInterfaceTitle(currentLogInterfaceId)"></span></h3>
            <button @click="confirmClearLogs(currentLogInterfaceId)"
                    class="btn btn-sm btn-error btn-outline">清空此日志
            </button>
        </div>
        <div class="log-modal-content bg-base-200 p-2 rounded">
            <ul class="space-y-2">
                <template x-for="log in filteredLogs()" :key="log.id">
                    <li class="p-2 rounded text-xs" :class="log.success ? 'bg-success/10' : 'bg-error/10'">
                        <div class="flex justify-between items-center mb-1"><span
                                class="font-medium text-base-content/80"
                                x-text="formatTimestamp(log.timestamp)"></span><span class="badge badge-sm"
                                                                                     :class="log.success ? 'badge-success' : 'badge-error'"
                                                                                     x-text="log.success ? '成功' : '失败'"></span>
                        </div>
                        <div class="text-base-content/70 space-y-0.5">
                            <p>URL: <code class="text-xs" x-text="log.url"></code></p>
                            <p>状态码: <span class="font-semibold" x-text="log.statusCode ?? 'N/A'"></span></p>
                            <p>响应时间: <span
                                    x-text="(log.responseTime !== null && log.responseTime !== undefined) ? log.responseTime + ' ms' : 'N/A'"></span>
                            </p>
                            <p>包含预期 (<code class="text-xs"
                                               x-text="getInterfaceExpectedText(log.interfaceId)"></code>): <span
                                    x-text="log.containsExpected ? '是' : '否'"></span></p>
                            <p x-show="!log.success && log.error" class="text-error font-medium">错误: <span
                                    x-text="log.error"></span></p>
                        </div>
                    </li>
                </template>
                <li x-show="filteredLogs().length === 0" class="text-center text-base-content/50 py-4">暂无日志记录。
                </li>
            </ul>
        </div>
        <div class="modal-action mt-4">
            <button type="button" class="btn btn-ghost"
                    @click="closeLogModal()">关闭
            </button>
        </div>
    </div>
    <div class="modal-backdrop">
        <button @click.prevent="closeLogModal()">close</button>
    </div>
</dialog>

<!-- Text Area Import Modal 通过文本区域导入模态框 -->
<dialog id="textImportModal" class="modal" x-ref="textImportModal">
    <div class="modal-box">
        <h3 class="font-bold text-lg mb-4">通过文本导入配置</h3>
        <p class="text-sm text-base-content/70 mb-4">
            请在下方粘贴 JSON 格式的接口配置数组。导入将<strong class="text-warning">合并</strong>到现有配置中 (Title
            相同的将更新，不同的将新增)。
        </p>
        <form @submit.prevent="handleTextInputImport">
            <div class="form-control">
                    <textarea class="textarea textarea-bordered h-48 font-mono text-sm" x-ref="importTextArea"
                              placeholder='[
{
    "id": "optional-id-1", // ID 是可选的, 如果提供且与现有 Title 冲突, 会被忽略
    "title": "My API 1 (必须, 唯一)",
    "url": "https://example.com/api/status1",
    "expectedText": "success",
    "timeout": 5,
    "favicon": "data:image/png;base64,..." // 可选
},
{
    "title": "My API 2 (必须, 唯一)",
    "url": "https://example.com/api/status2",
    "expectedText": "\"status\":\"ok\"",
    "timeout": 3
}
]'></textarea>
                <label class="label">
                        <span class="label-text-alt text-error" x-show="importTextError"
                              x-text="importTextError"></span>
                </label>
            </div>
            <div class="modal-action">
                <button type="button" class="btn btn-ghost" @click="closeTextImportModal()">取消</button>
                <button type="submit" class="btn btn-primary">确认导入</button>
            </div>
        </form>
    </div>
    <div class="modal-backdrop">
        <button @click.prevent="closeTextImportModal()">close</button>
    </div>
</dialog>

<!-- Toast Notifications Area 提示通知区域 -->
<div class="toast toast-top toast-end z-[9999]">
    <template x-for="toast in toasts" :key="toast.id">
        <div :class="['alert', toast.type === 'error' ? 'alert-error' : (toast.type === 'success' ? 'alert-success' : 'alert-warning'), 'shadow-lg', 'cursor-pointer']"
             @click="removeToast(toast.id)">
            <div class="flex-1"><span class="text-sm" x-text="toast.message"></span></div>
        </div>
    </template>
</div>

<!-- JavaScript 核心逻辑 -->
<script>
    // --- 常量定义 ---
    const DEFAULT_FAVICON_URI = "data:image/svg+xml;charset=utf-8;base64,PHN2ZyB0PSIxNzQ1MTQ1MTQ4ODA4IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjI3NTgiIHdpZHRoPSIyNTYiIGhlaWdodD0iMjU2Ij48cGF0aCBkPSJNNTEyIDMyQzI0Ni45MTIgMzIgMzIgMjQ2Ljg0OCAzMiA1MTJzMjE0LjkxMiA0ODAgNDgwIDQ4MGMyNjUuMTUyIDAgNDgwLTIxNC44NDggNDgwLTQ4MFM3NzcuMTUyIDMyIDUxMiAzMnpNMzIwLjI1NiAxNDMuMDRjMjAuODY0LTEwLjg4IDQyLjY4OC0yMC4xNiA2NS40MDgtMjcuMzkyLTIzLjYxNiAzNC42MjQtNDMuOTY4IDc4LjY1Ni01OS45MDQgMTI5LjYtMjMuODA4LTE1LjIzMi0zNy43Ni0zMy40NzItMzcuNzYtNTMuMjQ4IDAtMTcuOTg0IDEyLjIyNC0zNC41NiAzMi4yNTYtNDguOTZ6TTIyNy4xMzYgMjA5LjM0NGM3LjQyNCAzNy41NjggMzYuODY0IDcxLjI5NiA4Mi43NTIgOTYuNTEyLTExLjg0IDUzLjM3Ni0xOS4yIDExMi4wNjQtMjEuMTIgMTc0LjE0NEg5Ny42YTQxNC40NjQgNDE0LjQ2NCAwIDAgMSAxMjkuNTM2LTI3MC42NTZ6IG0wIDYwNS4zMTJBNDE0LjQ2NCA0MTQuNDY0IDAgMCAxIDk3LjYgNTQ0aDE5MS4xMDRjMS45MiA2Mi4wOCA5LjM0NCAxMjAuNzY4IDIxLjE4NCAxNzQuMTQ0LTQ1Ljg4OCAyNS4wODgtNzUuMzI4IDU4Ljk0NC04Mi43NTIgOTYuNTEyeiBtOTMuMTIgNjYuMzA0QzMwMC4yMjQgODY2LjU2IDI4OCA4NDkuOTIgMjg4IDgzMmMwLTE5Ljc3NiAxMy45NTItMzguMDggMzcuNzYtNTMuMzEyIDE1LjkzNiA1MS4wMDggMzYuMjg4IDk0Ljk3NiA1OS45MDQgMTI5LjY2NGE0MTEuMzkyIDQxMS4zOTIgMCAwIDEtNjUuNDA4LTI3LjM5MnogbTE1OS43NDQgMzguNjU2Yy00MC4xOTItMjEuMTg0LTc0LjgxNi04MS44NTYtOTcuOTItMTY1LjU2OGE0MjUuNTM2IDQyNS41MzYgMCAwIDEgOTcuOTItMTYuNzA0djE4Mi4yNzJ6IG0wLTI0NS44MjRhNDU0LjU5MiA0NTQuNTkyIDAgMCAwLTExMS42OCAyMC4yODhBOTY2LjQgOTY2LjQgMCAwIDEgMzUyLjY0IDU0NEg0ODB2MTI5Ljc5MnogbTAtMTkzLjc5MkgzNTIuNjRhOTY2LjQgOTY2LjQgMCAwIDEgMTUuNjgtMTUwLjA4IDQ2MC42MDggNDYwLjYwOCAwIDAgMCAxMTEuNjggMjAuMzUyVjQ4MHogbTAtMTkzLjM0NGE0MzIuNTEyIDQzMi41MTIgMCAwIDEtOTcuOTItMTYuNzA0YzIzLjEwNC04My43MTIgNTcuNzI4LTE0NC4zMiA5Ny45Mi0xNjUuNTY4djE4Mi4yNzJ6IG0zMTYuODY0LTc3LjMxMkE0MTQuMDggNDE0LjA4IDAgMCAxIDkyNi4zMzYgNDgwaC0xOTEuMTA0Yy0xLjkyLTYyLjA4LTkuMzQ0LTEyMC43NjgtMjEuMTg0LTE3NC4xNDQgNDUuOTUyLTI1LjE1MiA3NS4zOTItNTguOTQ0IDgyLjgxNi05Ni41MTJ6IG0tOTMuMTItNjYuMzA0YzIwLjAzMiAxNC40IDMyLjI1NiAzMC45NzYgMzIuMjU2IDQ4Ljk2IDAgMTkuNzc2LTEzLjk1MiAzOC4wMTYtMzcuNzYgNTMuMjQ4LTE1LjkzNi01MC45NDQtMzYuMjg4LTk0Ljk3Ni01OS45NjgtMTI5LjZhNDA5LjYgNDA5LjYgMCAwIDEgNjUuNDcyIDI3LjM5MnpNNTQ0IDEwNC4zODRjNDAuMjU2IDIxLjI0OCA3NC44OCA4MS44NTYgOTcuOTIgMTY1LjU2OGE0MzIuNTEyIDQzMi41MTIgMCAwIDEtOTcuOTIgMTYuNzA0VjEwNC4zODR6IG0wIDI0NS44ODhhNDYwLjA5NiA0NjAuMDk2IDAgMCAwIDExMS42OC0yMC4yODhjOC42NCA0NS44ODggMTQuMTQ0IDk2LjQ0OCAxNS42OCAxNTAuMDE2SDU0NFYzNTAuMjcyeiBtMCAxOTMuNzI4aDEyNy4zNmMtMS41MzYgNTMuNTY4LTcuMDQgMTA0LjEyOC0xNS42OCAxNTAuMTQ0YTQ1NC4wMTYgNDU0LjAxNiAwIDAgMC0xMTEuNjgtMjAuMjg4VjU0NHogbTAgMzc1LjYxNnYtMTgyLjI3MmE0MjUuNTM2IDQyNS41MzYgMCAwIDEgOTcuOTIgMTYuNzA0Yy0yMy4wNCA4My43MTItNTcuNjY0IDE0NC4zODQtOTcuOTIgMTY1LjU2OHogbTE1OS43NDQtMzguNjU2Yy0yMC44NjQgMTAuODgtNDIuNjg4IDIwLjE2LTY1LjQwOCAyNy40NTYgMjMuNjE2LTM0LjY4OCA0NC4wMzItNzguNjU2IDU5Ljk2OC0xMjkuNjY0IDIzLjgwOCAxNS4yMzIgMzcuNzYgMzMuNTM2IDM3Ljc2IDUzLjMxMi0wLjA2NCAxNy44NTYtMTIuMjg4IDM0LjQ5Ni0zMi4zMiA0OC44OTZ6IG05My4xMi02Ni4zMDRjLTcuNDI0LTM3LjU2OC0zNi45MjgtNzEuMzYtODIuODE2LTk2LjUxMmE5MzYuOTYgOTM2Ljk2IDAgMCAwIDIxLjE4NC0xNzQuMTQ0aDE5MS4xMDRhNDE0LjA4IDQxNC4wOCAwIDAgMS0xMjkuNDcyIDI3MC42NTZ6IiBmaWxsPSJjdXJyZW50Q29sb3IiIHAtaWQ9IjI3NTkiPjwvcGF0aD48L3N2Zz4=";
    const PROXY_BASE_URL = 'https://cors-proxy.wofbi233.workers.dev/';
    const DB_NAME = 'InterfaceMonitorDB_Daisy_v2';
    const DB_VERSION = 1;
    const INTERFACE_STORE = 'interfaces';
    const LOG_STORE = 'logs';

    // --- IndexedDB 数据库操作封装 ---
    function openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = (event) => reject("IndexedDB error: " + request.error?.message);
            request.onsuccess = (event) => resolve(event.target.result);
            request.onupgradeneeded = (event) => {
                console.log('IndexedDB upgrade needed...');
                const db = event.target.result;
                if (!db.objectStoreNames.contains(INTERFACE_STORE)) {
                    db.createObjectStore(INTERFACE_STORE, {keyPath: 'id'});
                }
                if (!db.objectStoreNames.contains(LOG_STORE)) {
                    const logStore = db.createObjectStore(LOG_STORE, {keyPath: 'id'});
                    logStore.createIndex('interfaceId', 'interfaceId', {unique: false});
                    logStore.createIndex('timestamp', 'timestamp', {unique: false});
                }
                console.log('IndexedDB upgrade complete.');
            };
        });
    }

    function dbAction(storeName, mode, action) {
        return openDB().then(db => {
            return new Promise((resolve, reject) => {
                if (!db.objectStoreNames.contains(storeName)) {
                    db.close();
                    return reject(`Object store "${storeName}" not found.`);
                }
                try {
                    const transaction = db.transaction(storeName, mode);
                    const store = transaction.objectStore(storeName);
                    let requestCompleted = false;
                    action(store, (result) => {
                        requestCompleted = true;
                        resolve(result);
                    }, (error) => {
                        requestCompleted = true;
                        reject(error);
                    });
                    transaction.oncomplete = () => {
                        db.close();
                        if (!requestCompleted) resolve();
                    };
                    transaction.onerror = (event) => {
                        db.close();
                        reject(`Transaction error on ${storeName}: ${event.target.error?.message || event.target.error}`);
                    };
                } catch (error) {
                    db.close();
                    reject(`Failed to start transaction on ${storeName}: ${error?.message || error}`);
                }
            });
        }).catch(err => {
            console.error(`IndexedDB action failed for store ${storeName}:`, err);
            throw err;
        });
    }

    function getAll(storeName) {
        return dbAction(storeName, 'readonly', (store, resolve, reject) => {
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result);
            request.onerror = (event) => reject(event.target.error);
        });
    }

    function saveItem(storeName, item) {
        return dbAction(storeName, 'readwrite', (store, resolve, reject) => {
            const request = store.put(item);
            request.onsuccess = () => resolve();
            request.onerror = (event) => reject(event.target.error);
        });
    }

    function deleteItem(storeName, key) {
        return dbAction(storeName, 'readwrite', (store, resolve, reject) => {
            const request = store.delete(key);
            request.onsuccess = () => resolve();
            request.onerror = (event) => reject(event.target.error);
        });
    }

    function deleteLogsByInterface(interfaceId) {
        return dbAction(LOG_STORE, 'readwrite', (store, resolve, reject) => {
            try {
                const index = store.index('interfaceId');
                const request = index.openCursor(IDBKeyRange.only(interfaceId));
                let deletePromises = [];
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        deletePromises.push(new Promise((res, rej) => {
                            try {
                                const deleteRequest = cursor.delete();
                                deleteRequest.onsuccess = res;
                                deleteRequest.onerror = (e) => rej(e.target.error);
                            } catch (delErr) {
                                rej(delErr);
                            }
                        }));
                        cursor.continue();
                    } else {
                        Promise.all(deletePromises).then(resolve).catch(reject);
                    }
                };
                request.onerror = (event) => reject(event.target.error);
            } catch (indexErr) {
                reject(`Error accessing index 'interfaceId' on store ${LOG_STORE}: ${indexErr.message}`);
            }
        });
    }

    function saveLog(logData) {
        return dbAction(LOG_STORE, 'readwrite', (store, resolve, reject) => {
            const addRequest = store.add(logData);
            addRequest.onsuccess = resolve;
            addRequest.onerror = (e) => reject(e.target.error);
        });
    }

    function pruneOldLogs(interfaceId, maxKept) {
        return dbAction(LOG_STORE, 'readwrite', (store, resolve, reject) => {
            try {
                const index = store.index('timestamp');
                let count = 0;
                const request = index.openCursor(null, 'prev');
                const logsToDelete = [];
                request.onsuccess = event => {
                    const cursor = event.target.result;
                    if (cursor) {
                        if (cursor.value.interfaceId === interfaceId) {
                            count++;
                            if (count > maxKept) {
                                logsToDelete.push(cursor.primaryKey);
                            }
                        }
                        cursor.continue();
                    } else {
                        let deletePromises = logsToDelete.map(logId => new Promise((res, rej) => {
                            try {
                                const delReq = store.delete(logId);
                                delReq.onsuccess = res;
                                delReq.onerror = e => rej(e.target.error);
                            } catch (delErr) {
                                rej(delErr);
                            }
                        }));
                        Promise.all(deletePromises).then(() => resolve(logsToDelete.length)).catch(reject);
                    }
                };
                request.onerror = event => reject(event.target.error);
            } catch (indexErr) {
                reject(`Error accessing index 'timestamp' on store ${LOG_STORE}: ${indexErr.message}`);
            }
        });
    }

    function clearStore(storeName) {
        return dbAction(storeName, 'readwrite', (store, resolve, reject) => {
            const request = store.clear();
            request.onsuccess = () => resolve();
            request.onerror = (event) => reject(event.target.error);
        });
    }

    // --- 结束 IndexedDB ---

    // --- 代理 Fetch 函数 ---
    async function fetchThroughProxy({url, method = 'GET', query = {}, body = null, headers = {}, signal}) {
        if (!url) throw new Error('目标URL是必需的');
        const urlObject = new URL(url);
        Object.entries(query).forEach(([key, value]) => urlObject.searchParams.append(key, value));
        const targetUrl = urlObject.toString();
        const proxyUrl = new URL(PROXY_BASE_URL);
        proxyUrl.searchParams.append('url', targetUrl);
        const fetchOptions = {
            method,
            headers: {...headers, 'Accept': 'application/json, text/plain, */*'},
            signal,
            body: (method !== 'GET' && method !== 'HEAD' && body) ? (typeof body === 'string' ? body : JSON.stringify(body)) : null,
        };
        if (fetchOptions.body && typeof body === 'object' && !headers['Content-Type']) {
            fetchOptions.headers['Content-Type'] = 'application/json';
        }
        console.log(`通过代理 ${proxyUrl.toString()} 请求 ${method} ${targetUrl}`);
        const response = await fetch(proxyUrl.toString(), fetchOptions);
        return response;
    }

    // --- Alpine.js 应用状态定义 ---
    function appState() {
        return {
            // --- 核心状态数据 ---
            interfaces: [], logs: [], newInterface: {title: '', url: '', expectedText: '', timeout: 3},
            editingInterface: null, currentLogInterfaceId: null, isDraggingOver: false,
            importTextError: null,

            // --- 应用配置项 ---
            pollingInterval: null, uiUpdateInterval: null, pollingFrequency: 15000,
            maxLogsPerInterface: 100, toasts: [],

            // --- 生命周期钩子 & 初始化 ---
            async init() {
                console.log('应用初始化...');
                try {
                    this.interfaces = await getAll(INTERFACE_STORE);
                    this.logs = await getAll(LOG_STORE);
                    console.log(`加载了 ${this.interfaces.length} 个接口, ${this.logs.length} 条日志。`);

                    const urlParams = new URLSearchParams(window.location.search);
                    const importUrl = urlParams.get('import');

                    let urlImportPromise = Promise.resolve(); // 创建一个立即解决的 Promise
                    if (importUrl) {
                        console.log(`发现导入 URL 参数: ${importUrl}`);
                        // 将 URL 导入包装在 Promise 中，以便后续可以等待它完成（即使它异步启动）
                        urlImportPromise = this.importFromUrl(importUrl).catch(err => {
                            console.error("URL 导入失败:", err);
                            this.addToast(`从 URL 导入失败: ${err.message}`, 'error', 6000);
                            // 即使 URL 导入失败，也继续执行后续初始化
                        });
                        // 可选：移除 URL 参数
                        // window.history.replaceState({}, document.title, window.location.pathname + window.location.hash);
                    }

                    // 等待 URL 导入（如果启动了）完成后再进行后续处理
                    await urlImportPromise;

                    // 只有在没有接口的情况下才添加示例（URL 导入后可能已经有接口了）
                    if (this.interfaces.length === 0 && !importUrl) { // 修正: 添加 !importUrl 条件
                        console.log("未发现接口且无URL导入，添加默认示例...");
                        const defaultIface = {
                            id: crypto.randomUUID(),
                            title: '示例接口 (Example.com)',
                            url: 'https://example.com/',
                            expectedText: 'Example Domain',
                            timeout: 5,
                            favicon: this.getFaviconUrl('https://example.com/'),
                            status: 'pending',
                            lastChecked: null,
                            lastResponseTime: null,
                            lastError: null,
                            nextCheckInSeconds: undefined
                        };
                        this.interfaces.push(defaultIface);
                        await this.saveInterfaces();
                        this.addToast('已添加一个示例接口，您可以编辑或删除它', 'info', 6000);
                    }

                    // 初始化或重新初始化所有接口状态（确保导入的数据也应用这些状态）
                    this.interfaces.forEach(iface => {
                        iface.status = iface.status === 'pending' ? 'pending' : (iface.status || 'pending');
                        if (!iface.favicon) iface.favicon = this.getFaviconUrl(iface.url);
                        if (typeof iface.timeout !== 'number' || iface.timeout <= 0) iface.timeout = 3;
                        iface.nextCheckInSeconds = undefined;
                    });

                    this.startPolling();
                    this.startUiUpdates();
                    console.log('初始化完成。');

                } catch (error) {
                    console.error("初始化失败:", error);
                    this.addToast(`加载本地数据失败: ${error.message}`, 'error'); // 显示更具体的错误
                }
            },

            // --- 轮询控制 ---
            startPolling() {
                if (this.pollingInterval) clearInterval(this.pollingInterval);
                console.log("尝试启动轮询...");
                if (this.interfaces.length === 0) {
                    console.log("无接口可监控，轮询未启动。");
                    return;
                }
                console.log("执行首次接口检查...");
                this.checkAllInterfaces();
                this.pollingInterval = setInterval(() => {
                    this.checkAllInterfaces();
                }, this.pollingFrequency);
                console.log(`轮询已启动: 每 ${this.pollingFrequency / 1000} 秒检查一次.`);
            },
            stopPolling() {
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                    this.pollingInterval = null;
                    console.log('轮询已停止。');
                }
            },
            startUiUpdates() {
                if (this.uiUpdateInterval) clearInterval(this.uiUpdateInterval);
                this.uiUpdateInterval = setInterval(() => {
                    this.updateNextCheckTimers();
                }, 1000);
                console.log('UI 更新定时器已启动。');
            },
            stopUiUpdates() {
                if (this.uiUpdateInterval) {
                    clearInterval(this.uiUpdateInterval);
                    this.uiUpdateInterval = null;
                    console.log('UI 更新定时器已停止。');
                }
            },

            // --- 核心检测逻辑 ---
            checkAllInterfaces() {
                console.log(`[${new Date().toLocaleTimeString()}] checkAllInterfaces: 正在检查 ${this.interfaces.length} 个接口...`);
                if (this.interfaces.length === 0) return;
                this.interfaces.forEach(iface => {
                    console.log(`---> 触发检查: ${iface.title} (ID: ${iface.id}, 当前状态: ${iface.status})`);
                    this.checkInterfaceStatus(iface.id);
                });
            },
            async checkInterfaceStatus(interfaceId) {
                const ifaceIndex = this.interfaces.findIndex(i => i.id === interfaceId);
                if (ifaceIndex === -1) {
                    console.warn(`checkInterfaceStatus: 未找到接口 ID ${interfaceId}。`);
                    return;
                }
                this.updateInterfaceState(interfaceId, {
                    status: 'pending',
                    lastError: null,
                    nextCheckInSeconds: undefined
                });
                let iface = this.interfaces[ifaceIndex];
                const controller = new AbortController();
                const timeoutValue = (typeof iface.timeout === 'number' && iface.timeout > 0) ? iface.timeout : 3;
                const timeoutMs = timeoutValue * 1000;
                const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
                const startTime = Date.now();
                let statusData = {
                    statusCode: null,
                    responseTime: null,
                    containsExpected: false,
                    success: false,
                    error: null,
                    timestamp: Date.now()
                };
                let finalState = {};
                try {
                    const response = await fetchThroughProxy({
                        url: iface.url,
                        method: 'GET',
                        headers: {
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        },
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    const endTime = Date.now();
                    statusData.responseTime = endTime - startTime;
                    statusData.statusCode = response.status;
                    if (response.ok) {
                        const text = await response.text();
                        statusData.containsExpected = typeof iface.expectedText === 'string' && text.includes(iface.expectedText);
                        if (statusData.containsExpected) {
                            statusData.success = true;
                            finalState = {
                                status: 'ok',
                                lastChecked: statusData.timestamp,
                                lastResponseTime: statusData.responseTime,
                                lastError: null
                            };
                        } else {
                            statusData.success = false;
                            statusData.error = '响应未包含预期字符';
                            finalState = {
                                status: 'error',
                                lastChecked: statusData.timestamp,
                                lastResponseTime: statusData.responseTime,
                                lastError: statusData.error
                            };
                            this.addToast(`"${iface.title}": ${statusData.error}`, 'warning');
                        }
                    } else {
                        statusData.success = false;
                        statusData.error = `HTTP状态码: ${response.status}`;
                        try {
                            const errorText = await response.text();
                            if (errorText) statusData.error += ` - ${errorText.substring(0, 100)}`;
                        } catch (_) { /* Ignore */
                        }
                        finalState = {
                            status: 'error',
                            lastChecked: statusData.timestamp,
                            lastResponseTime: statusData.responseTime,
                            lastError: statusData.error
                        };
                        this.addToast(`"${iface.title}": ${statusData.error}`, 'error');
                    }
                } catch (error) {
                    clearTimeout(timeoutId);
                    const endTime = Date.now();
                    statusData.responseTime = endTime - startTime;
                    statusData.success = false;
                    if (error.name === 'AbortError') {
                        statusData.error = `请求超时 (${timeoutMs / 1000}s)`;
                        finalState = {
                            status: 'error',
                            lastChecked: statusData.timestamp,
                            lastResponseTime: null,
                            lastError: statusData.error
                        };
                    } else {
                        statusData.error = `请求失败: ${error.message}`;
                        finalState = {
                            status: 'error',
                            lastChecked: statusData.timestamp,
                            lastResponseTime: null,
                            lastError: statusData.error
                        };
                        console.error(`代理请求错误 ${iface.url}:`, error);
                    }
                    this.addToast(`"${iface.title}": ${statusData.error}`, 'error');
                } finally {
                    this.updateInterfaceState(interfaceId, finalState);
                    this.addLog({
                        id: crypto.randomUUID(),
                        interfaceId: iface.id,
                        timestamp: statusData.timestamp,
                        url: iface.url,
                        statusCode: statusData.statusCode,
                        responseTime: statusData.responseTime,
                        containsExpected: statusData.containsExpected,
                        success: statusData.success,
                        error: statusData.error
                    });
                    this.updateNextCheckTimers();
                }
            },

            // --- 接口操作 (CRUD) ---
            addInterface() {
                const title = this.newInterface.title.trim();
                const url = this.newInterface.url.trim();
                const expectedText = this.newInterface.expectedText;
                let timeout = parseInt(this.newInterface.timeout, 10);
                if (isNaN(timeout) || timeout <= 0) timeout = 3;
                if (!title || !url || expectedText === undefined || expectedText === null) {
                    this.addToast('请填写所有必填项!', 'warning');
                    return;
                }
                try {
                    new URL(url);
                    if (!url.match(/^https?:\/\//i)) throw new Error("无效协议");
                } catch (e) {
                    this.addToast('URL 格式不正确 (需包含 http:// 或 https://)!', 'error');
                    return;
                }
                const newIface = {
                    id: crypto.randomUUID(),
                    title: title,
                    url: url,
                    expectedText: expectedText,
                    timeout: timeout,
                    favicon: this.getFaviconUrl(url),
                    status: 'pending',
                    lastChecked: null,
                    lastResponseTime: null,
                    lastError: null,
                    nextCheckInSeconds: undefined
                };
                this.interfaces.push(newIface);
                this.saveInterfaces();
                this.closeAddModal();
                this.resetNewInterfaceForm();
                this.addToast(`接口 "${title}" 已添加`, 'success');
                this.checkInterfaceStatus(newIface.id);
                if (this.interfaces.length === 1 && !this.pollingInterval) {
                    this.startPolling();
                    this.startUiUpdates();
                }
            },
            openEditModal(iface) {
                this.editingInterface = JSON.parse(JSON.stringify(iface));
                if (typeof this.editingInterface.timeout !== 'number') {
                    this.editingInterface.timeout = 3;
                }
                this.$refs?.editModal?.showModal();
                this.$nextTick(() => this.$refs?.editModal?.querySelector('input[type="text"]')?.focus());
            },
            closeEditModal() {
                if (this.$refs?.editModal?.open) this.$refs.editModal.close();
                this.editingInterface = null;
            },
            updateInterface() {
                if (!this.editingInterface) return;
                const {id, title: rawTitle, url: rawUrl, expectedText, timeout: rawTimeout} = this.editingInterface;
                const title = rawTitle.trim();
                const url = rawUrl.trim();
                let timeout = parseInt(rawTimeout, 10);
                if (isNaN(timeout) || timeout <= 0) timeout = 3;
                if (!title || !url || expectedText === undefined || expectedText === null) {
                    this.addToast('请填写所有必填项!', 'warning');
                    return;
                }
                try {
                    new URL(url);
                    if (!url.match(/^https?:\/\//i)) throw new Error("无效协议");
                } catch (e) {
                    this.addToast('URL 格式不正确!', 'error');
                    return;
                }
                const index = this.interfaces.findIndex(i => i.id === id);
                if (index !== -1) {
                    const originalInterface = this.interfaces[index];
                    this.interfaces[index] = {
                        ...originalInterface,
                        title,
                        url,
                        expectedText,
                        timeout,
                        favicon: this.getFaviconUrl(url)
                    };
                    this.saveInterfaces();
                    this.closeEditModal();
                    this.addToast(`接口 "${title}" 已更新`, 'success');
                    this.checkInterfaceStatus(id);
                } else {
                    this.addToast('更新失败：未找到接口', 'error');
                    this.closeEditModal();
                }
            },
            confirmDeleteInterface(id) {
                const iface = this.interfaces.find(i => i.id === id);
                if (!iface) return;
                Swal.fire({
                    title: `确认删除接口 "${iface.title}"?`,
                    text: "将同时删除所有相关日志记录，此操作不可恢复!",
                    icon: 'warning',
                    showCancelButton: true,
                    confirmButtonColor: '#d33',
                    cancelButtonColor: '#3085d6',
                    confirmButtonText: '确认删除',
                    cancelButtonText: '取消'
                }).then((result) => {
                    if (result.isConfirmed) {
                        this.deleteInterface(id);
                    }
                });
            },
            async deleteInterface(id) {
                const ifaceToDelete = this.interfaces.find(i => i.id === id);
                const titleToDelete = ifaceToDelete ? ifaceToDelete.title : '未知';
                this.interfaces = this.interfaces.filter(i => i.id !== id);
                this.logs = this.logs.filter(log => log.interfaceId !== id);
                try {
                    await deleteItem(INTERFACE_STORE, id);
                    await deleteLogsByInterface(id);
                    console.log(`接口 ${id} (${titleToDelete}) 及其日志已从数据库删除。`);
                    this.addToast(`接口 "${titleToDelete}" 已删除`, 'success');
                    if (this.interfaces.length === 0) {
                        this.stopPolling();
                        this.stopUiUpdates();
                    }
                } catch (error) {
                    console.error(`数据库删除接口/日志错误 (ID: ${id}):`, error);
                    this.addToast('删除接口或日志时出错。', 'error');
                }
            },
            updateInterfaceState(id, newState) {
                const index = this.interfaces.findIndex(i => i.id === id);
                if (index !== -1) {
                    this.interfaces[index] = {...this.interfaces[index], ...newState};
                } else {
                    console.warn(`updateInterfaceState: 未找到接口 ID ${id} (可能已被删除)。`);
                }
            },

            // --- 日志管理 ---
            async addLog(logData) {
                this.logs.push(logData);
                const interfaceLogs = this.logs.filter(log => log.interfaceId === logData.interfaceId).sort((a, b) => b.timestamp - a.timestamp);
                const logsToRemoveFromMemory = interfaceLogs.slice(this.maxLogsPerInterface);
                if (logsToRemoveFromMemory.length > 0) {
                    const idsToRemove = new Set(logsToRemoveFromMemory.map(l => l.id));
                    this.logs = this.logs.filter(log => !idsToRemove.has(log.id));
                }
                try {
                    await saveLog(logData);
                    const prunedCount = await pruneOldLogs(logData.interfaceId, this.maxLogsPerInterface);
                    if (prunedCount > 0) {
                        console.log(`为接口 ${logData.interfaceId} 从数据库清理了 ${prunedCount} 条旧日志。`);
                    }
                } catch (e) {
                    console.error("后台日志保存/清理失败:", e);
                }
            },
            filteredLogs() {
                if (!this.currentLogInterfaceId) return [];
                return this.logs.filter(log => log.interfaceId === this.currentLogInterfaceId).sort((a, b) => b.timestamp - a.timestamp);
            },
            confirmClearLogs(interfaceId) {
                const iface = this.interfaces.find(i => i.id === interfaceId);
                if (!iface) return;
                this.closeLogModal();
                this.$nextTick(() => {
                    Swal.fire({
                        title: `确认清空接口 "${iface.title}" 的所有日志?`,
                        text: "此操作不可恢复!",
                        icon: 'warning',
                        showCancelButton: true,
                        confirmButtonColor: '#d33',
                        cancelButtonColor: '#3085d6',
                        confirmButtonText: '确认清空',
                        cancelButtonText: '取消',
                    }).then((result) => {
                        if (result.isConfirmed) {
                            this.clearLogs(interfaceId);
                        }
                    });
                });
            },
            async clearLogs(interfaceId) {
                const logsBefore = this.logs.filter(log => log.interfaceId === interfaceId).length;
                this.logs = this.logs.filter(log => log.interfaceId !== interfaceId);
                try {
                    await deleteLogsByInterface(interfaceId);
                    console.log(`已为接口 ${interfaceId} 清空 ${logsBefore} 条日志 (内存和数据库)。`);
                    this.addToast(`已清空 ${logsBefore} 条日志`, 'success');
                } catch (error) {
                    console.error(`数据库清空日志错误 (ID: ${interfaceId}):`, error);
                    this.addToast('清空数据库日志时出错。', 'error');
                }
            },

            // --- IndexedDB 持久化操作 ---
            async saveInterfaces() {
                try {
                    const dataToSave = this.interfaces.map(iface => JSON.parse(JSON.stringify(iface)));
                    await Promise.all(dataToSave.map(iface => saveItem(INTERFACE_STORE, iface)));
                    console.log('接口列表已保存至 IndexedDB。');
                } catch (e) {
                    console.error("保存接口列表错误:", e);
                    this.addToast('保存接口列表失败!', 'error');
                }
            },

            // --- 导入/导出 ---
            exportConfig() {
                console.log("正在导出配置...");
                try {
                    const interfacesToExport = JSON.parse(JSON.stringify(this.interfaces));
                    const configOnly = interfacesToExport.map(({
                                                                   id,
                                                                   title,
                                                                   url,
                                                                   expectedText,
                                                                   timeout,
                                                                   favicon
                                                               }) => ({
                        id,
                        title,
                        url,
                        expectedText,
                        timeout,
                        favicon
                    }));
                    const jsonString = JSON.stringify(configOnly, null, 2);
                    const blob = new Blob([jsonString], {type: 'application/json'});
                    const downloadUrl = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = downloadUrl;
                    a.download = `interface-monitor-config_${new Date().toISOString().slice(0, 10)}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(downloadUrl);
                    this.addToast('配置已成功导出!', 'success');
                    console.log("配置导出成功。");
                } catch (error) {
                    console.error("导出失败:", error);
                    this.addToast('导出配置失败!', 'error');
                }
            },
            importConfigTrigger() {
                this.$refs.fileInput.click();
            },
            handleFileDrop(event) {
                console.log("检测到文件拖放。");
                this.isDraggingOver = false;
                const files = event.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type === 'application/json') {
                        this.processImportFile(file);
                    } else {
                        this.addToast('请拖放有效的 JSON 文件 (.json)!', 'error');
                    }
                } else {
                    console.log("拖放事件中未找到文件。");
                }
                event.preventDefault();
            },
            handleFileImport(event) {
                const file = event.target.files[0];
                if (!file) {
                    console.log("未通过输入框选择文件。");
                    event.target.value = null;
                    return;
                }
                if (file.type !== 'application/json') {
                    this.addToast('请选择一个有效的 JSON 文件 (.json)!', 'error');
                    event.target.value = null;
                    return;
                }
                this.processImportFile(file);
                event.target.value = null;
            },
            openTextImportModal() {
                this.importTextError = null;
                if (this.$refs.importTextArea) {
                    this.$refs.importTextArea.value = '';
                }
                this.$refs?.textImportModal?.showModal();
                this.$nextTick(() => this.$refs?.importTextArea?.focus());
            },
            closeTextImportModal() {
                this.importTextError = null;
                this.$refs?.textImportModal?.close();
            },
            async handleTextInputImport() {
                this.importTextError = null;
                const jsonString = this.$refs.importTextArea.value.trim();
                if (!jsonString) {
                    this.importTextError = "请输入 JSON 配置内容。";
                    return;
                }
                try {
                    const importedData = JSON.parse(jsonString);
                    this.closeTextImportModal();
                    await this.processImportedData(importedData, false);
                } catch (error) {
                    console.error("Text import failed:", error);
                    this.importTextError = `导入处理失败: ${error.message}`;
                }
            },
            async importFromUrl(urlToFetch) {
                if (!urlToFetch) return;
                this.addToast(`正在从 URL 导入: ${this.truncateUrl(urlToFetch, 50)}...`, 'info');
                try {
                    const response = await fetchThroughProxy({url: urlToFetch});
                    if (!response.ok) {
                        throw new Error(`获取 URL 失败: HTTP ${response.status}`);
                    }
                    const importedData = await response.json();
                    await this.processImportedData(importedData, true);
                } catch (error) {
                    console.error(`Error importing from URL ${urlToFetch}:`, error);
                    throw new Error(`无法从 URL [${this.truncateUrl(urlToFetch)}] 导入: ${error.message}`);
                }
            },
            processImportFile(file) {
                if (!file) return;
                console.log(`正在处理导入文件: ${file.name}`);
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const jsonString = e.target.result;
                    try {
                        const importedData = JSON.parse(jsonString);
                        await this.processImportedData(importedData, false);
                    } catch (error) {
                        console.error("File import failed:", error);
                        this.addToast(`导入失败: ${error.message}`, 'error', 6000);
                    }
                };
                reader.onerror = (e) => {
                    console.error("File reading error:", e);
                    this.addToast('读取文件时出错!', 'error');
                };
                reader.readAsText(file);
            },

            // --- 核心: 验证、合并(更新或新增)并保存接口配置 ---
            async processImportedData(importedData, skipConfirmation = false) {
                console.log("Processing imported data. Skip confirmation:", skipConfirmation);
                try {
                    if (!Array.isArray(importedData)) {
                        throw new Error("导入的数据必须是一个数组。");
                    }
                    const validatedInterfaces = [];
                    const importedTitles = new Set();

                    for (const item of importedData) {
                        if (typeof item.title !== 'string' || !item.title.trim()) {
                            console.warn("跳过缺少或无效 Title 的项目:", item);
                            continue;
                        }
                        const trimmedTitle = item.title.trim();
                        if (importedTitles.has(trimmedTitle)) {
                            console.warn(`跳过导入数据中的重复 Title: '${trimmedTitle}'`);
                            continue;
                        }
                        if (typeof item.url !== 'string' || !item.url.trim()) {
                            console.warn(`跳过 Title '${trimmedTitle}' 的项目，缺少 URL。`);
                            continue;
                        }
                        if (typeof item.expectedText !== 'string') {
                            console.warn(`跳过 Title '${trimmedTitle}' 的项目，缺少 expectedText。`);
                            continue;
                        }
                        try {
                            new URL(item.url);
                            if (!item.url.match(/^https?:\/\//i)) throw new Error();
                        } catch {
                            console.warn(`跳过 Title '${trimmedTitle}' 的项目，URL 无效: ${item.url}`);
                            continue;
                        }

                        importedTitles.add(trimmedTitle);
                        validatedInterfaces.push({
                            id: item.id || crypto.randomUUID(),
                            title: trimmedTitle,
                            url: item.url.trim(),
                            expectedText: item.expectedText,
                            timeout: (typeof item.timeout === 'number' && item.timeout > 0) ? item.timeout : 3,
                            favicon: item.favicon || this.getFaviconUrl(item.url.trim()),
                            status: 'pending',
                            lastChecked: null,
                            lastResponseTime: null,
                            lastError: null,
                            nextCheckInSeconds: undefined
                        });
                    }
                    if (validatedInterfaces.length === 0) {
                        throw new Error("未找到有效的、可处理的接口配置。");
                    }

                    const interfacesToAdd = [];
                    const interfacesToUpdate = [];
                    let updateCount = 0;
                    let addCount = 0;
                    const existingTitleMap = new Map();
                    this.interfaces.forEach(iface => existingTitleMap.set(iface.title.trim(), iface.id));

                    for (const newItem of validatedInterfaces) {
                        const existingId = existingTitleMap.get(newItem.title);
                        if (existingId) {
                            console.log(`准备更新 Title 为 '${newItem.title}' (ID: ${existingId}) 的接口。`);
                            const updatedItem = {...newItem, id: existingId};
                            interfacesToUpdate.push(updatedItem);
                            updateCount++;
                        } else {
                            console.log(`准备新增 Title 为 '${newItem.title}' 的接口。`);
                            interfacesToAdd.push(newItem);
                            addCount++;
                        }
                    }

                    if (addCount === 0 && updateCount === 0) {
                        this.addToast('没有需要新增或更新的接口。', 'warning');
                        console.log("Import processing finished: No items to add or update.");
                        return;
                    }

                    let confirmText = "";
                    if (updateCount > 0) confirmText += `将更新 ${updateCount} 个同名接口。`;
                    if (addCount > 0) confirmText += `${updateCount > 0 ? ' ' : ''}将新增 ${addCount} 个接口。`;
                    confirmText += " 是否继续？";
                    let isConfirmed = skipConfirmation;
                    if (!skipConfirmation) {
                        const result = await Swal.fire({
                            title: '确认导入?',
                            text: confirmText,
                            icon: 'info',
                            showCancelButton: true,
                            confirmButtonColor: '#3085d6',
                            cancelButtonColor: '#d33',
                            confirmButtonText: '确认操作',
                            cancelButtonText: '取消'
                        });
                        isConfirmed = result.isConfirmed;
                    }

                    if (isConfirmed) {
                        console.log("Merge import confirmed (or skipped).");
                        this.stopPolling();
                        this.stopUiUpdates();
                        try {
                            interfacesToUpdate.forEach(updatedItem => {
                                const index = this.interfaces.findIndex(i => i.id === updatedItem.id);
                                if (index !== -1) {
                                    this.interfaces[index] = updatedItem;
                                }
                            });
                            this.interfaces.push(...interfacesToAdd);
                            const itemsToSave = [...interfacesToUpdate, ...interfacesToAdd];
                            await Promise.all(itemsToSave.map(iface => saveItem(INTERFACE_STORE, JSON.parse(JSON.stringify(iface)))));
                            let successMsg = "";
                            if (updateCount > 0) successMsg += `成功更新 ${updateCount} 个接口。`;
                            if (addCount > 0) successMsg += `${updateCount > 0 ? ' ' : ''}成功新增 ${addCount} 个接口。`;
                            this.addToast(successMsg, 'success');
                            console.log("Merge import successful.");
                            itemsToSave.forEach(iface => this.checkInterfaceStatus(iface.id));
                            this.startPolling();
                            this.startUiUpdates();
                        } catch (dbError) {
                            console.error("Error saving merged interfaces to DB:", dbError);
                            this.addToast('合并导入接口时数据库操作失败!', 'error');
                            this.startPolling();
                            this.startUiUpdates();
                            throw dbError;
                        }
                    } else {
                        console.log("Merge import cancelled by user.");
                        if (!skipConfirmation) {
                            this.addToast('导入操作已取消。', 'info');
                        }
                    }
                } catch (processingError) {
                    console.error("Error processing import data:", processingError);
                    throw processingError;
                }
            }, // processImportedData 函数结束


            // --- UI 与辅助函数 ---
            resetNewInterfaceForm() {
                this.newInterface = {title: '', url: '', expectedText: '', timeout: 3};
            },
            openAddModal() {
                console.log('openAddModal called');
                this.resetNewInterfaceForm();
                this.$refs?.addModal?.showModal();
                this.$nextTick(() => this.$refs?.addModal?.querySelector('input[type="text"]')?.focus());
            },
            closeAddModal() {
                this.$refs?.addModal?.close();
            },
            openLogModal(id) {
                this.currentLogInterfaceId = id;
                this.$refs?.logModal?.showModal();
            },
            closeLogModal() {
                if (this.$refs?.logModal?.open) this.$refs.logModal.close();
                this.currentLogInterfaceId = null;
            },
            getFaviconUrl(baseUrl) {
                try {
                    const url = new URL(baseUrl);
                    return `${url.protocol}//${url.hostname}/favicon.ico`;
                } catch (e) {
                    return DEFAULT_FAVICON_URI;
                }
            },
            getStatusText(status) {
                const map = {ok: '正常', error: '异常', pending: '检测中...'};
                return map[status] || '待检测';
            },
            formatTimestamp(timestamp) {
                if (!timestamp) return 'N/A';
                try {
                    return new Date(timestamp).toLocaleString('zh-CN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });
                } catch (e) {
                    return '无效日期';
                }
            },
            truncateUrl(url, length = 50) {
                if (!url) return '';
                return url.length > length ? url.substring(0, length) + '...' : url;
            }, // 增加长度以便URL导入提示
            getInterfaceTitle(id) {
                const iface = this.interfaces.find(i => i.id === id);
                return iface ? iface.title : '未知接口';
            },
            getInterfaceExpectedText(id) {
                const iface = this.interfaces.find(i => i.id === id);
                return iface ? (iface.expectedText === '' ? '(空)' : iface.expectedText) : 'N/A';
            },
            updateNextCheckTimers() {
                const now = Date.now();
                this.interfaces.forEach(iface => {
                    if (iface.lastChecked && iface.status !== 'pending') {
                        const elapsed = now - iface.lastChecked;
                        const remaining = this.pollingFrequency - elapsed;
                        iface.nextCheckInSeconds = Math.max(0, Math.round(remaining / 1000));
                    } else if (iface.status !== 'pending') {
                        iface.nextCheckInSeconds = undefined;
                    }
                });
            },

            // --- Toast 通知 ---
            addToast(message, type = 'info', duration = 4000) {
                const id = crypto.randomUUID();
                this.toasts.push({id, message, type});
                setTimeout(() => this.removeToast(id), duration);
            },
            removeToast(id) {
                this.toasts = this.toasts.filter(t => t.id !== id);
            },

        } // appState 返回对象结束
    } // appState 函数结束
</script>

</body>

</html>
