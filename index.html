<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP接口健康监控</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.12.24/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com/3.4.16"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <!-- 确保 Alpine 在 SweetAlert 和 Tailwind 之后加载 -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.14.9/dist/cdn.min.js"></script>
    <style>
        /* 隐藏未初始化的 Alpine 元素，防止闪烁 */
        [x-cloak] {
            display: none !important;
        }

        /* Favicon 图片样式 */
        .favicon-img {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            flex-shrink: 0;
            object-fit: contain;
        }

        /* 日志模态框内容区域样式 */
        .log-modal-content {
            max-height: 60vh;
            /* 最大高度，超出则滚动 */
            overflow-y: auto;
            /* 垂直方向滚动 */
        }

        /* 卡片底部按钮间距 */
        .card-actions .btn {
            margin-left: 0.25rem;
        }

        /* 卡片标题区域布局 */
        .card-title-area {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 4px;
        }

        /* 覆盖 daisyUI 默认的卡片标题下边距 */
        .card-title-area .card-title {
            margin-bottom: 0;
        }

        /* 防止按钮组换行 */
        .card-title-area .btn-group {
            flex-shrink: 0;
        }
    </style>
</head>

<body class="bg-base-200 text-base-content min-h-screen" x-data="appState()" x-init="init()" x-cloak>

    <!-- Navbar 导航栏 -->
    <div class="navbar bg-primary text-primary-content shadow-md sticky top-0 z-50">
        <div class="flex-1">
            <a class="btn btn-ghost text-xl">接口健康监控</a>
        </div>
        <div class="flex-none gap-2">
            <!-- 导入/导出 按钮组 -->
            <div class="dropdown dropdown-end">
                <button tabindex="0" role="button" class="btn btn-ghost">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                        stroke="currentColor" class="w-5 h-5 mr-1">
                        <path stroke-linecap="round" stroke-linejoin="round"
                            d="M12 10.5v6m3-3H9m4.06-7.19-2.12-2.12a1.5 1.5 0 0 0-1.061-.44H4.5A2.25 2.25 0 0 0 2.25 6v12a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18V9a2.25 2.25 0 0 0-2.25-2.25h-5.379a1.5 1.5 0 0 1-1.06-.44Z" />
                    </svg>
                    管理
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                        stroke="currentColor" class="w-4 h-4 ml-1">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
                    </svg>
                </button>
                <ul tabindex="0"
                    class="dropdown-content z-[1] menu p-2 shadow bg-base-100 rounded-box w-52 text-base-content">
                    <li><a @click="importConfigTrigger()">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                                stroke="currentColor" class="w-4 h-4 mr-2">
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M9 8.25H7.5a2.25 2.25 0 0 0-2.25 2.25v9a2.25 2.25 0 0 0 2.25 2.25h9a2.25 2.25 0 0 0 2.25-2.25v-9a2.25 2.25 0 0 0-2.25-2.25H15M9 12l3 3m0 0 3-3m-3 3V2.25" />
                            </svg>
                            导入配置 (.json)</a></li>
                    <li><a @click="exportConfig()">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                                stroke="currentColor" class="w-4 h-4 mr-2">
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3" />
                            </svg>
                            导出配置 (.json)</a></li>
                </ul>
            </div>
            <!-- 新增接口 按钮 -->
            <button class="btn btn-accent" @click="openAddModal()">+ 新增接口</button>
            <!-- 隐藏的文件输入框，用于点击触发导入 -->
            <input type="file" class="hidden" x-ref="fileInput" @change="handleFileImport($event)" accept=".json">
        </div>
    </div>

    <!-- 主内容区域: 接口卡片网格 + 拖拽导入区域 -->
    <main class="p-4 md:p-6 transition-colors duration-200 relative min-h-[calc(100vh-10rem)]"
        :class="{ 'bg-primary/10 border-2 border-dashed border-primary': isDraggingOver }"
        @dragover.prevent="isDraggingOver = true" @dragleave.prevent="isDraggingOver = false"
        @drop.prevent="handleFileDrop($event)">
        <!-- 可选: 拖拽时的视觉提示遮罩层 -->
        <div x-show="isDraggingOver"
            class="absolute inset-0 flex items-center justify-center text-primary font-semibold text-lg pointer-events-none z-10">
            拖拽 .json 文件到此处导入
        </div>

        <!-- 卡片网格 -->
        <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 md:gap-6 relative z-0"
            :class="{ 'opacity-50': isDraggingOver }"> <!-- 可选: 拖拽时内容变暗 -->

            <!-- 卡片模板 (循环渲染接口) -->
            <template x-for="iface in interfaces" :key="iface.id">
                <div class="card bg-base-100 shadow-xl border-t-4 min-h-[210px] flex flex-col justify-between" :class="{
                        'border-success': iface.status === 'ok',
                        'border-error': iface.status === 'error',
                        'border-warning': iface.status === 'pending',
                        'border-base-300': !iface.status
                     }">
                    <div class="card-body p-4">
                        <div class="card-title-area mb-2">
                            <div class="flex items-center min-w-0 flex-1">
                                <img :src="iface.favicon || DEFAULT_FAVICON_URI"
                                    @error="if (event.target.src !== DEFAULT_FAVICON_URI) event.target.src = DEFAULT_FAVICON_URI"
                                    alt="favicon" class="favicon-img">
                                <h2 class="card-title text-lg truncate" x-text="iface.title" :title="iface.title">
                                </h2>
                            </div>
                            <div class="btn-group">
                                <!-- 编辑按钮 -->
                                <button @click="openEditModal(iface)"
                                    class="btn btn-xs btn-ghost text-info hover:bg-info/10 p-1" title="编辑接口">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="black" width="16" height="16"
                                        viewBox="0 0 24 24">
                                        <title>text-box-edit-outline</title>
                                        <path
                                            d="M10 21H5C3.89 21 3 20.11 3 19V5C3 3.89 3.89 3 5 3H19C20.11 3 21 3.89 21 5V10.33C20.7 10.21 20.37 10.14 20.04 10.14C19.67 10.14 19.32 10.22 19 10.37V5H5V19H10.11L10 19.11V21M7 9H17V7H7V9M7 17H12.11L14 15.12V15H7V17M7 13H16.12L17 12.12V11H7V13M21.7 13.58L20.42 12.3C20.21 12.09 19.86 12.09 19.65 12.3L18.65 13.3L20.7 15.35L21.7 14.35C21.91 14.14 21.91 13.79 21.7 13.58M12 22H14.06L20.11 15.93L18.06 13.88L12 19.94V22Z" />
                                    </svg>

                                </button>
                                <!-- 删除按钮 -->
                                <button @click="confirmDeleteInterface(iface.id)"
                                    class="btn btn-xs btn-ghost text-error hover:bg-error/10 p-1" title="删除接口">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="red" width="16" height="16" viewBox="0 0 24 24">
                                        <title>trash-can-outline</title>
                                        <path
                                            d="M9,3V4H4V6H5V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V6H20V4H15V3H9M7,6H17V19H7V6M9,8V17H11V8H9M13,8V17H15V8H13Z" />
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- URL 信息 -->
                        <p class="text-xs text-base-content/70 break-all mb-2" :title="iface.url"
                            x-text="truncateUrl(iface.url)">
                        </p>

                        <!-- 状态和响应时间 -->
                        <div class="flex items-center text-sm mb-1">
                            <span class="mr-1 text-xl"
                                :class="{ 'text-success': iface.status === 'ok', 'text-error': iface.status === 'error', 'text-warning': iface.status === 'pending', 'text-base-content/50': !iface.status }">
                                <span x-show="iface.status === 'ok'">✅</span>
                                <span x-show="iface.status === 'error'">❌</span>
                                <span x-show="iface.status === 'pending'"><span
                                        class="loading loading-spinner loading-xs"></span></span>
                                <span x-show="!iface.status">-</span>
                            </span>
                            <span class="font-medium"
                                :class="{ 'text-success': iface.status === 'ok', 'text-error': iface.status === 'error', 'text-warning': iface.status === 'pending', 'text-base-content/70': !iface.status }">
                                <span x-text="getStatusText(iface.status)"></span>
                                <span x-show="iface.status === 'ok' && iface.lastResponseTime !== undefined"
                                    x-text="' (' + iface.lastResponseTime + 'ms)'"></span>
                            </span>
                        </div>
                        <!-- 错误原因 -->
                        <p class="text-xs text-error" x-show="iface.status === 'error' && iface.lastError"
                            x-text="'原因: ' + iface.lastError"></p>

                        <!-- 上次和下次检测时间 -->
                        <p class="text-xs text-base-content/50 mt-1" x-show="iface.lastChecked"
                            x-text="'上次检测: ' + formatTimestamp(iface.lastChecked)"></p>
                        <p class="text-xs text-base-content/50 mt-1"
                            x-show="iface.lastChecked && iface.status !== 'pending' && iface.nextCheckInSeconds !== undefined"
                            x-text="'下次检测: ' + (iface.nextCheckInSeconds > 0 ? iface.nextCheckInSeconds + ' 秒后' : '即将进行...')">
                        </p>
                    </div>
                    <!-- 卡片底部操作 -->
                    <div class="card-actions justify-end p-4 pt-0">
                        <button class="btn btn-sm btn-outline btn-info" @click="openLogModal(iface.id)">查看日志</button>
                    </div>
                </div>
            </template> <!-- 卡片模板结束 -->

            <!-- 空状态占位符: 仅在没有接口且没有拖拽悬浮时显示 -->
            <div x-show="interfaces.length === 0 && !isDraggingOver"
                class="col-span-full text-center py-10 text-base-content/70">
                <div class="card bg-base-100 shadow-md p-6 inline-block">
                    <p class="mb-4">还没有监控任何接口。</p>
                    <!-- 空状态下的按钮组 -->
                    <div class="flex gap-2 justify-center">
                        <button @click="openAddModal()" class="btn btn-primary">
                            点击添加第一个
                        </button>
                        <button @click="importConfigTrigger()" class="btn btn-secondary">
                            或导入配置
                        </button>
                    </div>
                </div>
            </div>

        </div> <!-- 网格结束 -->
    </main>

    <!-- Add Interface Modal 新增接口模态框 -->
    <dialog id="addInterfaceModal" class="modal" x-ref="addModal">
        <div class="modal-box">
            <h3 class="font-bold text-lg mb-4">新增监控接口</h3>
            <form @submit.prevent="addInterface()">
                <!-- 表单控件 -->
                <div class="form-control w-full mb-4">
                    <label class="label"><span class="label-text">接口标题 <span class="text-error">*</span></span></label>
                    <input type="text" x-model="newInterface.title" required placeholder="例如：用户API状态"
                        class="input input-bordered w-full" />
                </div>
                <div class="form-control w-full mb-4">
                    <label class="label"><span class="label-text">接口 URL <span class="text-error">*</span>
                            (http/https)</span></label>
                    <input type="text" x-model="newInterface.url" required pattern="^(https?|http)://.+"
                        placeholder="https://example.com/api/status" class="input input-bordered w-full" />
                </div>
                <div class="form-control w-full mb-4">
                    <label class="label"><span class="label-text">预期返回包含字符 <span
                                class="text-error">*</span></span></label>
                    <input type="text" x-model="newInterface.expectedText" required
                        placeholder='例如: success, "status":"ok"' class="input input-bordered w-full" />
                </div>
                <div class="form-control w-full mb-4">
                    <label class="label"><span class="label-text">超时时间 (秒, 默认3)</span></label>
                    <input type="number" x-model.number="newInterface.timeout" min="1" placeholder="3"
                        class="input input-bordered w-full" />
                </div>
                <!-- 模态框操作按钮 -->
                <div class="modal-action">
                    <button type="button" class="btn btn-ghost" @click="closeAddModal()">取消</button>
                    <button type="submit" class="btn btn-primary">确认添加</button>
                </div>
            </form>
        </div>
        <!-- 点击背景关闭模态框 -->
        <div class="modal-backdrop">
            <button @click.prevent="closeAddModal()">close</button>
        </div>
    </dialog>

    <!-- Edit Interface Modal 编辑接口模态框 -->
    <dialog id="editInterfaceModal" class="modal" x-ref="editModal">
        <div class="modal-box">
            <!-- 仅当 editingInterface 有对象时才渲染表单，防止 null 错误 -->
            <template x-if="editingInterface">
                <div>
                    <h3 class="font-bold text-lg mb-4">编辑监控接口</h3>
                    <form @submit.prevent="updateInterface()">
                        <!-- 编辑表单控件 -->
                        <div class="form-control w-full mb-4">
                            <label class="label"><span class="label-text">接口标题 <span
                                        class="text-error">*</span></span></label>
                            <input type="text" x-model="editingInterface.title" required placeholder="例如：用户API状态"
                                class="input input-bordered w-full" />
                        </div>
                        <div class="form-control w-full mb-4">
                            <label class="label"><span class="label-text">接口 URL <span class="text-error">*</span>
                                    (http/https)</span></label>
                            <input type="text" x-model="editingInterface.url" required pattern="^(https?|http)://.+"
                                placeholder="https://example.com/api/status" class="input input-bordered w-full" />
                        </div>
                        <div class="form-control w-full mb-4">
                            <label class="label"><span class="label-text">预期返回包含字符 <span
                                        class="text-error">*</span></span></label>
                            <input type="text" x-model="editingInterface.expectedText" required
                                placeholder='例如: success, "status":"ok"' class="input input-bordered w-full" />
                        </div>
                        <div class="form-control w-full mb-4">
                            <label class="label"><span class="label-text">超时时间 (秒)</span></label>
                            <input type="number" x-model.number="editingInterface.timeout" min="1" placeholder="3"
                                class="input input-bordered w-full" />
                        </div>
                        <!-- 模态框操作按钮 -->
                        <div class="modal-action">
                            <button type="button" class="btn btn-ghost" @click="closeEditModal()">取消</button>
                            <button type="submit" class="btn btn-primary">保存更改</button>
                        </div>
                    </form>
                </div>
            </template>
            <!-- 可选: editingInterface 为 null 时显示的内容 -->
            <div x-show="!editingInterface" class="text-center p-4">
                <!-- <span class="loading loading-spinner"></span> -->
            </div>
        </div>
        <!-- 点击背景关闭模态框 -->
        <div class="modal-backdrop">
            <button @click.prevent="closeEditModal()">close</button>
        </div>
    </dialog>

    <!-- Log Viewer Modal 日志查看模态框 -->
    <dialog id="logModal" class="modal" x-ref="logModal">
        <div class="modal-box w-11/12 max-w-5xl">
            <!-- 模态框头部 -->
            <div class="flex justify-between items-center mb-4">
                <h3 class="font-bold text-lg">接口日志: <span x-text="getInterfaceTitle(currentLogInterfaceId)"></span></h3>
                <button @click="confirmClearLogs(currentLogInterfaceId)"
                    class="btn btn-sm btn-error btn-outline">清空此日志</button>
            </div>
            <!-- 日志列表容器 -->
            <div class="log-modal-content bg-base-200 p-2 rounded">
                <ul class="space-y-2">
                    <!-- 循环渲染日志条目 -->
                    <template x-for="log in filteredLogs()" :key="log.id">
                        <li class="p-2 rounded text-xs" :class="log.success ? 'bg-success/10' : 'bg-error/10'">
                            <div class="flex justify-between items-center mb-1">
                                <span class="font-medium text-base-content/80"
                                    x-text="formatTimestamp(log.timestamp)"></span>
                                <span class="badge badge-sm" :class="log.success ? 'badge-success' : 'badge-error'"
                                    x-text="log.success ? '成功' : '失败'"></span>
                            </div>
                            <div class="text-base-content/70 space-y-0.5">
                                <p>URL: <code class="text-xs" x-text="log.url"></code></p>
                                <p>状态码: <span class="font-semibold" x-text="log.statusCode ?? 'N/A'"></span></p>
                                <p>响应时间: <span
                                        x-text="(log.responseTime !== null && log.responseTime !== undefined) ? log.responseTime + ' ms' : 'N/A'"></span>
                                </p>
                                <p>包含预期 (<code class="text-xs"
                                        x-text="getInterfaceExpectedText(log.interfaceId)"></code>): <span
                                        x-text="log.containsExpected ? '是' : '否'"></span></p>
                                <p x-show="!log.success && log.error" class="text-error font-medium">错误: <span
                                        x-text="log.error"></span></p>
                            </div>
                        </li>
                    </template>
                    <!-- 无日志时的提示 -->
                    <li x-show="filteredLogs().length === 0" class="text-center text-base-content/50 py-4">暂无日志记录。</li>
                </ul>
            </div>
            <!-- 模态框底部操作 -->
            <div class="modal-action mt-4">
                <button type="button" class="btn btn-ghost" @click="closeLogModal()">关闭</button>
            </div>
        </div>
        <!-- 点击背景关闭模态框 -->
        <div class="modal-backdrop">
            <button @click.prevent="closeLogModal()">close</button>
        </div>
    </dialog>

    <!-- Toast Notifications Area 提示通知区域 -->
    <div class="toast toast-top toast-end z-[9999]">
        <template x-for="toast in toasts" :key="toast.id">
            <div :class="['alert', toast.type === 'error' ? 'alert-error' : (toast.type === 'success' ? 'alert-success' : 'alert-warning'), 'shadow-lg', 'cursor-pointer']"
                @click="removeToast(toast.id)">
                <div class="flex-1">
                    <span class="text-sm" x-text="toast.message"></span>
                </div>
            </div>
        </template>
    </div>

    <!-- JavaScript 核心逻辑 -->
    <script>
        // --- 常量定义 ---
        const DEFAULT_FAVICON_URI = "data:image/svg+xml;charset=utf-8;base64,PHN2ZyB0PSIxNzQ1MTQ1MTQ4ODA4IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjI3NTgiIHdpZHRoPSIyNTYiIGhlaWdodD0iMjU2Ij48cGF0aCBkPSJNNTEyIDMyQzI0Ni45MTIgMzIgMzIgMjQ2Ljg0OCAzMiA1MTJzMjE0LjkxMiA0ODAgNDgwIDQ4MGMyNjUuMTUyIDAgNDgwLTIxNC44NDggNDgwLTQ4MFM3NzcuMTUyIDMyIDUxMiAzMnpNMzIwLjI1NiAxNDMuMDRjMjAuODY0LTEwLjg4IDQyLjY4OC0yMC4xNiA2NS40MDgtMjcuMzkyLTIzLjYxNiAzNC42MjQtNDMuOTY4IDc4LjY1Ni01OS45MDQgMTI5LjYtMjMuODA4LTE1LjIzMi0zNy43Ni0zMy40NzItMzcuNzYtNTMuMjQ4IDAtMTcuOTg0IDEyLjIyNC0zNC41NiAzMi4yNTYtNDguOTZ6TTIyNy4xMzYgMjA5LjM0NGM3LjQyNCAzNy41NjggMzYuODY0IDcxLjI5NiA4Mi43NTIgOTYuNTEyLTExLjg0IDUzLjM3Ni0xOS4yIDExMi4wNjQtMjEuMTIgMTc0LjE0NEg5Ny42YTQxNC40NjQgNDE0LjQ2NCAwIDAgMSAxMjkuNTM2LTI3MC42NTZ6IG0wIDYwNS4zMTJBNDE0LjQ2NCA0MTQuNDY0IDAgMCAxIDk3LjYgNTQ0aDE5MS4xMDRjMS45MiA2Mi4wOCA5LjM0NCAxMjAuNzY4IDIxLjE4NCAxNzQuMTQ0LTQ1Ljg4OCAyNS4wODgtNzUuMzI4IDU4Ljk0NC04Mi43NTIgOTYuNTEyeiBtOTMuMTIgNjYuMzA0QzMwMC4yMjQgODY2LjU2IDI4OCA4NDkuOTIgMjg4IDgzMmMwLTE5Ljc3NiAxMy45NTItMzguMDggMzcuNzYtNTMuMzEyIDE1LjkzNiA1MS4wMDggMzYuMjg4IDk0Ljk3NiA1OS45MDQgMTI5LjY2NGE0MTEuMzkyIDQxMS4zOTIgMCAwIDEtNjUuNDA4LTI3LjM5MnogbTE1OS43NDQgMzguNjU2Yy00MC4xOTItMjEuMTg0LTc0LjgxNi04MS44NTYtOTcuOTItMTY1LjU2OGE0MjUuNTM2IDQyNS41MzYgMCAwIDEgOTcuOTItMTYuNzA0djE4Mi4yNzJ6IG0wLTI0NS44MjRhNDU0LjU5MiA0NTQuNTkyIDAgMCAwLTExMS42OCAyMC4yODhBOTY2LjQgOTY2LjQgMCAwIDEgMzUyLjY0IDU0NEg0ODB2MTI5Ljc5MnogbTAtMTkzLjc5MkgzNTIuNjRhOTY2LjQgOTY2LjQgMCAwIDEgMTUuNjgtMTUwLjA4IDQ2MC42MDggNDYwLjYwOCAwIDAgMCAxMTEuNjggMjAuMzUyVjQ4MHogbTAtMTkzLjM0NGE0MzIuNTEyIDQzMi41MTIgMCAwIDEtOTcuOTItMTYuNzA0YzIzLjEwNC04My43MTIgNTcuNzI4LTE0NC4zMiA5Ny45Mi0xNjUuNTY4djE4Mi4yNzJ6IG0zMTYuODY0LTc3LjMxMkE0MTQuMDggNDE0LjA4IDAgMCAxIDkyNi4zMzYgNDgwaC0xOTEuMTA0Yy0xLjkyLTYyLjA4LTkuMzQ0LTEyMC43NjgtMjEuMTg0LTE3NC4xNDQgNDUuOTUyLTI1LjE1MiA3NS4zOTItNTguOTQ0IDgyLjgxNi05Ni41MTJ6IG0tOTMuMTItNjYuMzA0YzIwLjAzMiAxNC40IDMyLjI1NiAzMC45NzYgMzIuMjU2IDQ4Ljk2IDAgMTkuNzc2LTEzLjk1MiAzOC4wMTYtMzcuNzYgNTMuMjQ4LTE1LjkzNi01MC45NDQtMzYuMjg4LTk0Ljk3Ni01OS45NjgtMTI5LjZhNDA5LjYgNDA5LjYgMCAwIDEgNjUuNDcyIDI3LjM5MnpNNTQ0IDEwNC4zODRjNDAuMjU2IDIxLjI0OCA3NC44OCA4MS44NTYgOTcuOTIgMTY1LjU2OGE0MzIuNTEyIDQzMi41MTIgMCAwIDEtOTcuOTIgMTYuNzA0VjEwNC4zODR6IG0wIDI0NS44ODhhNDYwLjA5NiA0NjAuMDk2IDAgMCAwIDExMS42OC0yMC4yODhjOC42NCA0NS44ODggMTQuMTQ0IDk2LjQ0OCAxNS42OCAxNTAuMDE2SDU0NFYzNTAuMjcyeiBtMCAxOTMuNzI4aDEyNy4zNmMtMS41MzYgNTMuNTY4LTcuMDQgMTA0LjEyOC0xNS42OCAxNTAuMTQ0YTQ1NC4wMTYgNDU0LjAxNiAwIDAgMC0xMTEuNjgtMjAuMjg4VjU0NHogbTAgMzc1LjYxNnYtMTgyLjI3MmE0MjUuNTM2IDQyNS41MzYgMCAwIDEgOTcuOTIgMTYuNzA0Yy0yMy4wNCA4My43MTItNTcuNjY0IDE0NC4zODQtOTcuOTIgMTY1LjU2OHogbTE1OS43NDQtMzguNjU2Yy0yMC44NjQgMTAuODgtNDIuNjg4IDIwLjE2LTY1LjQwOCAyNy40NTYgMjMuNjE2LTM0LjY4OCA0NC4wMzItNzguNjU2IDU5Ljk2OC0xMjkuNjY0IDIzLjgwOCAxNS4yMzIgMzcuNzYgMzMuNTM2IDM3Ljc2IDUzLjMxMi0wLjA2NCAxNy44NTYtMTIuMjg4IDM0LjQ5Ni0zMi4zMiA0OC44OTZ6IG05My4xMi02Ni4zMDRjLTcuNDI0LTM3LjU2OC0zNi45MjgtNzEuMzYtODIuODE2LTk2LjUxMmE5MzYuOTYgOTM2Ljk2IDAgMCAwIDIxLjE4NC0xNzQuMTQ0aDE5MS4xMDRhNDE0LjA4IDQxNC4wOCAwIDAgMS0xMjkuNDcyIDI3MC42NTZ6IiBmaWxsPSJjdXJyZW50Q29sb3IiIHAtaWQ9IjI3NTkiPjwvcGF0aD48L3N2Zz4=";
        const PROXY_BASE_URL = 'https://cors-proxy.wofbi233.workers.dev/'; // 替换为你的 CORS 代理地址
        const DB_NAME = 'InterfaceMonitorDB_Daisy_v2'; // 数据库名称
        const DB_VERSION = 1; // 数据库版本
        const INTERFACE_STORE = 'interfaces'; // 接口对象仓库名称
        const LOG_STORE = 'logs'; // 日志对象仓库名称

        // --- IndexedDB 数据库操作封装 ---
        // 打开数据库
        function openDB() { /* ...保持不变... */ return new Promise((resolve, reject) => { const request = indexedDB.open(DB_NAME, DB_VERSION); request.onerror = (event) => reject("IndexedDB error: " + request.error); request.onsuccess = (event) => resolve(event.target.result); request.onupgradeneeded = (event) => { console.log('IndexedDB upgrade needed...'); const db = event.target.result; if (!db.objectStoreNames.contains(INTERFACE_STORE)) { db.createObjectStore(INTERFACE_STORE, { keyPath: 'id' }); } if (!db.objectStoreNames.contains(LOG_STORE)) { const logStore = db.createObjectStore(LOG_STORE, { keyPath: 'id' }); logStore.createIndex('interfaceId', 'interfaceId', { unique: false }); logStore.createIndex('timestamp', 'timestamp', { unique: false }); } console.log('IndexedDB upgrade complete.'); }; }); }
        // 执行数据库事务操作
        function dbAction(storeName, mode, action) { /* ...保持不变... */ return openDB().then(db => { return new Promise((resolve, reject) => { try { const transaction = db.transaction(storeName, mode); const store = transaction.objectStore(storeName); action(store, resolve, reject); transaction.oncomplete = () => { db.close(); if (action.length <= 1) resolve(); }; transaction.onerror = (event) => { db.close(); reject(`Transaction error on ${storeName}: ${event.target.error}`); }; } catch (error) { db.close(); reject(`Failed to start transaction on ${storeName}: ${error}`); } }); }); }
        // 获取所有数据
        function getAll(storeName) { /* ...保持不变... */ return dbAction(storeName, 'readonly', (store, resolve, reject) => { const request = store.getAll(); request.onsuccess = () => resolve(request.result); request.onerror = (event) => reject(`Get all error from ${storeName}: ${event.target.error}`); }); }
        // 保存或更新单条数据 (put)
        function saveItem(storeName, item) { /* ...保持不变... */ return dbAction(storeName, 'readwrite', (store, resolve, reject) => { const request = store.put(item); request.onsuccess = () => resolve(); request.onerror = (event) => reject(`Save/Update error in ${storeName}: ${event.target.error}`); }); }
        // 删除单条数据
        function deleteItem(storeName, key) { /* ...保持不变... */ return dbAction(storeName, 'readwrite', (store, resolve, reject) => { const request = store.delete(key); request.onsuccess = () => resolve(); request.onerror = (event) => reject(`Delete error from ${storeName}: ${event.target.error}`); }); }
        // 根据接口ID删除相关日志
        function deleteLogsByInterface(interfaceId) { /* ...保持不变... */ return dbAction(LOG_STORE, 'readwrite', (store, resolve, reject) => { const index = store.index('interfaceId'); const request = index.openCursor(IDBKeyRange.only(interfaceId)); let deletePromises = []; request.onsuccess = (event) => { const cursor = event.target.result; if (cursor) { deletePromises.push(new Promise((res, rej) => { const deleteRequest = cursor.delete(); deleteRequest.onsuccess = res; deleteRequest.onerror = (e) => rej(e.target.error); })); cursor.continue(); } else { Promise.all(deletePromises).then(resolve).catch(reject); } }; request.onerror = (event) => reject(`Cursor error for deleting logs: ${event.target.error}`); }); }
        // 保存单条日志
        function saveLog(logData) { /* ...保持不变... */ return dbAction(LOG_STORE, 'readwrite', (store, resolve, reject) => { const addRequest = store.add(logData); addRequest.onsuccess = resolve; addRequest.onerror = (e) => reject(e.target.error); }); }
        // 清理旧日志 (保留最新的 maxKept 条)
        function pruneOldLogs(interfaceId, maxKept) { /* ...保持不变... */ return dbAction(LOG_STORE, 'readwrite', (store, resolve, reject) => { const index = store.index('timestamp'); let count = 0; const request = index.openCursor(null, 'prev'); const logsToDelete = []; request.onsuccess = event => { const cursor = event.target.result; if (cursor) { if (cursor.value.interfaceId === interfaceId) { count++; if (count > maxKept) { logsToDelete.push(cursor.primaryKey); } } cursor.continue(); } else { let deletePromises = logsToDelete.map(logId => new Promise((res, rej) => { const delReq = store.delete(logId); delReq.onsuccess = res; delReq.onerror = e => rej(e.target.error); })); Promise.all(deletePromises).then(() => resolve(logsToDelete.length)).catch(reject); } }; request.onerror = event => reject(`Cursor error for pruning logs: ${event.target.error}`); }); }
        // 清空整个对象仓库
        function clearStore(storeName) { /* ...保持不变... */ return dbAction(storeName, 'readwrite', (store, resolve, reject) => { const request = store.clear(); request.onsuccess = () => resolve(); request.onerror = (event) => reject(`Clear store error for ${storeName}: ${event.target.error}`); }); }
        // --- 结束 IndexedDB ---

        // --- 代理 Fetch 函数 ---
        async function fetchThroughProxy({ url, method = 'GET', query = {}, body = null, headers = {}, signal }) { /* ...保持不变... */ if (!url) throw new Error('目标URL是必需的'); const urlObject = new URL(url); Object.entries(query).forEach(([key, value]) => urlObject.searchParams.append(key, value)); const targetUrl = urlObject.toString(); const proxyUrl = new URL(PROXY_BASE_URL); proxyUrl.searchParams.append('url', targetUrl); const fetchOptions = { method, headers: { ...headers, }, signal, body: (method !== 'GET' && method !== 'HEAD' && body) ? (typeof body === 'string' ? body : JSON.stringify(body)) : null, }; if (fetchOptions.body && typeof body === 'object' && !headers['Content-Type']) { fetchOptions.headers['Content-Type'] = 'application/json'; } console.log(`通过代理 ${proxyUrl.toString()} 请求 ${method} ${targetUrl}`); const response = await fetch(proxyUrl.toString(), fetchOptions); return response; }

        // --- Alpine.js 应用状态定义 ---
        function appState() {
            return {
                // --- 核心状态数据 ---
                interfaces: [], // 监控接口对象数组
                logs: [],       // 日志记录数组 (内存缓存)
                newInterface: { title: '', url: '', expectedText: '', timeout: 3 }, // 新增接口表单模型
                editingInterface: null, // 当前正在编辑的接口对象副本 (null 表示未编辑)
                currentLogInterfaceId: null, // 当前查看日志的接口ID
                isDraggingOver: false, // 标记是否有文件拖拽悬浮在主区域上

                // --- 应用配置项 ---
                pollingInterval: null,    // 轮询定时器ID
                uiUpdateInterval: null,   // UI 更新定时器ID (如下次检测倒计时)
                pollingFrequency: 15000, // 轮询频率 (毫秒, 15秒)
                maxLogsPerInterface: 100, // 每个接口保留的最大日志条数 (内存和DB)
                toasts: [],              // 提示消息数组

                // --- 生命周期钩子 & 初始化 ---
                async init() {
                    console.log('应用初始化...');
                    try {
                        // 1. 从 IndexedDB 加载数据
                        this.interfaces = await getAll(INTERFACE_STORE);
                        this.logs = await getAll(LOG_STORE);
                        console.log(`加载了 ${this.interfaces.length} 个接口, ${this.logs.length} 条日志。`);

                        // 2. 处理加载的数据或添加示例
                        if (this.interfaces.length === 0) {
                            // 如果没有接口，添加一个默认示例
                            console.log("未发现接口，添加默认示例...");
                            const defaultIface = {
                                id: crypto.randomUUID(), title: '示例接口 (Example.com)', url: 'https://example.com/',
                                expectedText: 'Example Domain', timeout: 5, favicon: this.getFaviconUrl('https://example.com/'),
                                status: 'pending', lastChecked: null, lastResponseTime: null, lastError: null, nextCheckInSeconds: undefined
                            };
                            this.interfaces.push(defaultIface);
                            await this.saveInterfaces(); // 保存示例到数据库
                            this.addToast('已添加一个示例接口，您可以编辑或删除它', 'info', 6000);
                        } else {
                            // 初始化现有接口的状态和默认值
                            this.interfaces.forEach(iface => {
                                iface.status = iface.status === 'pending' ? 'pending' : (iface.status || 'pending'); // 确保初始状态
                                if (!iface.favicon) iface.favicon = this.getFaviconUrl(iface.url); // 补全 favicon
                                if (typeof iface.timeout !== 'number' || iface.timeout <= 0) iface.timeout = 3; // 设置默认超时
                                iface.nextCheckInSeconds = undefined; // 初始化下次检测时间显示
                            });
                        }

                        // 3. 启动轮询和 UI 更新
                        this.startPolling();
                        this.startUiUpdates();
                        console.log('初始化完成。');

                    } catch (error) {
                        console.error("初始化失败:", error);
                        this.addToast('加载本地数据失败!', 'error');
                    }
                },

                // --- 轮询控制 ---
                startPolling() { /* ...保持不变... */ if (this.pollingInterval) clearInterval(this.pollingInterval); console.log("尝试启动轮询..."); if (this.interfaces.length === 0) { console.log("无接口可监控，轮询未启动。"); return; } console.log("执行首次接口检查..."); this.checkAllInterfaces(); this.pollingInterval = setInterval(() => { this.checkAllInterfaces(); }, this.pollingFrequency); console.log(`轮询已启动: 每 ${this.pollingFrequency / 1000} 秒检查一次.`); },
                stopPolling() { /* ...保持不变... */ if (this.pollingInterval) { clearInterval(this.pollingInterval); this.pollingInterval = null; console.log('轮询已停止。'); } },
                startUiUpdates() { /* ...保持不变... */ if (this.uiUpdateInterval) clearInterval(this.uiUpdateInterval); this.uiUpdateInterval = setInterval(() => { this.updateNextCheckTimers(); }, 1000); console.log('UI 更新定时器已启动。'); },
                stopUiUpdates() { /* ...保持不变... */ if (this.uiUpdateInterval) { clearInterval(this.uiUpdateInterval); this.uiUpdateInterval = null; console.log('UI 更新定时器已停止。'); } },

                // --- 核心检测逻辑 ---
                checkAllInterfaces() { /* ...保持不变... */ console.log(`[${new Date().toLocaleTimeString()}] checkAllInterfaces: 正在检查 ${this.interfaces.length} 个接口...`); if (this.interfaces.length === 0) return; this.interfaces.forEach(iface => { console.log(`---> 触发检查: ${iface.title} (ID: ${iface.id}, 当前状态: ${iface.status})`); this.checkInterfaceStatus(iface.id); }); },
                async checkInterfaceStatus(interfaceId) { /* ...保持不变... */ const ifaceIndex = this.interfaces.findIndex(i => i.id === interfaceId); if (ifaceIndex === -1) { console.warn(`checkInterfaceStatus: 未找到接口 ID ${interfaceId}。`); return; } this.updateInterfaceState(interfaceId, { status: 'pending', lastError: null, nextCheckInSeconds: undefined }); let iface = this.interfaces[ifaceIndex]; const controller = new AbortController(); const timeoutValue = (typeof iface.timeout === 'number' && iface.timeout > 0) ? iface.timeout : 3; const timeoutMs = timeoutValue * 1000; const timeoutId = setTimeout(() => controller.abort(), timeoutMs); const startTime = Date.now(); let statusData = { statusCode: null, responseTime: null, containsExpected: false, success: false, error: null, timestamp: Date.now() }; let finalState = {}; try { const response = await fetchThroughProxy({ url: iface.url, method: 'GET', headers: { 'Cache-Control': 'no-cache, no-store, must-revalidate', 'Pragma': 'no-cache', 'Expires': '0' }, signal: controller.signal }); clearTimeout(timeoutId); const endTime = Date.now(); statusData.responseTime = endTime - startTime; statusData.statusCode = response.status; if (response.ok) { const text = await response.text(); statusData.containsExpected = typeof iface.expectedText === 'string' && text.includes(iface.expectedText); if (statusData.containsExpected) { statusData.success = true; finalState = { status: 'ok', lastChecked: statusData.timestamp, lastResponseTime: statusData.responseTime, lastError: null }; } else { statusData.success = false; statusData.error = '响应未包含预期字符'; finalState = { status: 'error', lastChecked: statusData.timestamp, lastResponseTime: statusData.responseTime, lastError: statusData.error }; this.addToast(`"${iface.title}": ${statusData.error}`, 'warning'); } } else { statusData.success = false; statusData.error = `HTTP状态码: ${response.status}`; try { const errorText = await response.text(); if (errorText) statusData.error += ` - ${errorText.substring(0, 100)}`; } catch (_) { /* Ignore */ } finalState = { status: 'error', lastChecked: statusData.timestamp, lastResponseTime: statusData.responseTime, lastError: statusData.error }; this.addToast(`"${iface.title}": ${statusData.error}`, 'error'); } } catch (error) { clearTimeout(timeoutId); const endTime = Date.now(); statusData.responseTime = endTime - startTime; statusData.success = false; if (error.name === 'AbortError') { statusData.error = `请求超时 (${timeoutMs / 1000}s)`; finalState = { status: 'error', lastChecked: statusData.timestamp, lastResponseTime: null, lastError: statusData.error }; } else { statusData.error = `请求失败: ${error.message}`; finalState = { status: 'error', lastChecked: statusData.timestamp, lastResponseTime: null, lastError: statusData.error }; console.error(`代理请求错误 ${iface.url}:`, error); } this.addToast(`"${iface.title}": ${statusData.error}`, 'error'); } finally { this.updateInterfaceState(interfaceId, finalState); this.addLog({ id: crypto.randomUUID(), interfaceId: iface.id, timestamp: statusData.timestamp, url: iface.url, statusCode: statusData.statusCode, responseTime: statusData.responseTime, containsExpected: statusData.containsExpected, success: statusData.success, error: statusData.error }); this.updateNextCheckTimers(); } },

                // --- 接口操作 (CRUD) ---
                addInterface() { /* ...保持不变... */ const title = this.newInterface.title.trim(); const url = this.newInterface.url.trim(); const expectedText = this.newInterface.expectedText; let timeout = parseInt(this.newInterface.timeout, 10); if (isNaN(timeout) || timeout <= 0) timeout = 3; if (!title || !url || expectedText === undefined || expectedText === null) { this.addToast('请填写所有必填项!', 'warning'); return; } try { new URL(url); if (!url.match(/^https?:\/\//i)) throw new Error("无效协议"); } catch (e) { this.addToast('URL 格式不正确 (需包含 http:// 或 https://)!', 'error'); return; } const newIface = { id: crypto.randomUUID(), title: title, url: url, expectedText: expectedText, timeout: timeout, favicon: this.getFaviconUrl(url), status: 'pending', lastChecked: null, lastResponseTime: null, lastError: null, nextCheckInSeconds: undefined }; this.interfaces.push(newIface); this.saveInterfaces(); this.closeAddModal(); this.resetNewInterfaceForm(); this.addToast(`接口 "${title}" 已添加`, 'success'); this.checkInterfaceStatus(newIface.id); if (this.interfaces.length === 1 && !this.pollingInterval) { this.startPolling(); this.startUiUpdates(); } },
                openEditModal(iface) { /* ...保持不变... */ this.editingInterface = JSON.parse(JSON.stringify(iface)); if (typeof this.editingInterface.timeout !== 'number') { this.editingInterface.timeout = 3; } this.$refs?.editModal?.showModal(); this.$nextTick(() => this.$refs?.editModal?.querySelector('input[type="text"]')?.focus()); },
                closeEditModal() { /* ...保持不变... */ if (this.$refs?.editModal?.open) this.$refs.editModal.close(); this.editingInterface = null; },
                updateInterface() { /* ...保持不变... */ if (!this.editingInterface) return; const { id, title: rawTitle, url: rawUrl, expectedText, timeout: rawTimeout } = this.editingInterface; const title = rawTitle.trim(); const url = rawUrl.trim(); let timeout = parseInt(rawTimeout, 10); if (isNaN(timeout) || timeout <= 0) timeout = 3; if (!title || !url || expectedText === undefined || expectedText === null) { this.addToast('请填写所有必填项!', 'warning'); return; } try { new URL(url); if (!url.match(/^https?:\/\//i)) throw new Error("无效协议"); } catch (e) { this.addToast('URL 格式不正确!', 'error'); return; } const index = this.interfaces.findIndex(i => i.id === id); if (index !== -1) { const originalInterface = this.interfaces[index]; this.interfaces[index] = { ...originalInterface, title, url, expectedText, timeout, favicon: this.getFaviconUrl(url) }; this.saveInterfaces(); this.closeEditModal(); this.addToast(`接口 "${title}" 已更新`, 'success'); this.checkInterfaceStatus(id); } else { this.addToast('更新失败：未找到接口', 'error'); this.closeEditModal(); } },
                confirmDeleteInterface(id) { /* ...保持不变... */ const iface = this.interfaces.find(i => i.id === id); if (!iface) return; Swal.fire({ title: `确认删除接口 "${iface.title}"?`, text: "将同时删除所有相关日志记录，此操作不可恢复!", icon: 'warning', showCancelButton: true, confirmButtonColor: '#d33', cancelButtonColor: '#3085d6', confirmButtonText: '确认删除', cancelButtonText: '取消' }).then((result) => { if (result.isConfirmed) { this.deleteInterface(id); } }); },
                async deleteInterface(id) { /* ...保持不变... */ const ifaceToDelete = this.interfaces.find(i => i.id === id); const titleToDelete = ifaceToDelete ? ifaceToDelete.title : '未知'; this.interfaces = this.interfaces.filter(i => i.id !== id); this.logs = this.logs.filter(log => log.interfaceId !== id); try { await deleteItem(INTERFACE_STORE, id); await deleteLogsByInterface(id); console.log(`接口 ${id} (${titleToDelete}) 及其日志已从数据库删除。`); this.addToast(`接口 "${titleToDelete}" 已删除`, 'success'); if (this.interfaces.length === 0) { this.stopPolling(); this.stopUiUpdates(); } } catch (error) { console.error(`数据库删除接口/日志错误 (ID: ${id}):`, error); this.addToast('删除接口或日志时出错。', 'error'); } },
                updateInterfaceState(id, newState) { /* ...保持不变... */ const index = this.interfaces.findIndex(i => i.id === id); if (index !== -1) { this.interfaces[index] = { ...this.interfaces[index], ...newState }; } else { console.warn(`updateInterfaceState: 未找到接口 ID ${id} (可能已被删除)。`); } },

                // --- 日志管理 ---
                async addLog(logData) { /* ...保持不变... */ this.logs.push(logData); const interfaceLogs = this.logs.filter(log => log.interfaceId === logData.interfaceId).sort((a, b) => b.timestamp - a.timestamp); const logsToRemoveFromMemory = interfaceLogs.slice(this.maxLogsPerInterface); if (logsToRemoveFromMemory.length > 0) { const idsToRemove = new Set(logsToRemoveFromMemory.map(l => l.id)); this.logs = this.logs.filter(log => !idsToRemove.has(log.id)); } try { await saveLog(logData); const prunedCount = await pruneOldLogs(logData.interfaceId, this.maxLogsPerInterface); if (prunedCount > 0) { console.log(`为接口 ${logData.interfaceId} 从数据库清理了 ${prunedCount} 条旧日志。`); } } catch (e) { console.error("后台日志保存/清理失败:", e); } },
                filteredLogs() { /* ...保持不变... */ if (!this.currentLogInterfaceId) return []; return this.logs.filter(log => log.interfaceId === this.currentLogInterfaceId).sort((a, b) => b.timestamp - a.timestamp); },
                confirmClearLogs(interfaceId) { /* ...保持不变... */ const iface = this.interfaces.find(i => i.id === interfaceId); if (!iface) return; this.closeLogModal(); this.$nextTick(() => { Swal.fire({ title: `确认清空接口 "${iface.title}" 的所有日志?`, text: "此操作不可恢复!", icon: 'warning', showCancelButton: true, confirmButtonColor: '#d33', cancelButtonColor: '#3085d6', confirmButtonText: '确认清空', cancelButtonText: '取消', }).then((result) => { if (result.isConfirmed) { this.clearLogs(interfaceId); } }); }); },
                async clearLogs(interfaceId) { /* ...保持不变... */ const logsBefore = this.logs.filter(log => log.interfaceId === interfaceId).length; this.logs = this.logs.filter(log => log.interfaceId !== interfaceId); try { await deleteLogsByInterface(interfaceId); console.log(`已为接口 ${interfaceId} 清空 ${logsBefore} 条日志 (内存和数据库)。`); this.addToast(`已清空 ${logsBefore} 条日志`, 'success'); } catch (error) { console.error(`数据库清空日志错误 (ID: ${interfaceId}):`, error); this.addToast('清空数据库日志时出错。', 'error'); } },
                // clearAllLogs 已被移除，因为导入现在是附加模式

                // --- IndexedDB 持久化操作 ---
                async saveInterfaces() { /* ...保持不变... */ try { const dataToSave = this.interfaces.map(iface => JSON.parse(JSON.stringify(iface))); await Promise.all(dataToSave.map(iface => saveItem(INTERFACE_STORE, iface))); console.log('接口列表已保存至 IndexedDB。'); } catch (e) { console.error("保存接口列表错误:", e); this.addToast('保存接口列表失败!', 'error'); } },

                // --- 导入/导出 ---
                exportConfig() {
                    // 导出配置逻辑 (保持不变)
                    console.log("正在导出配置...");
                    try {
                        const interfacesToExport = JSON.parse(JSON.stringify(this.interfaces));
                        const configOnly = interfacesToExport.map(({ id, title, url, expectedText, timeout, favicon }) => ({ id, title, url, expectedText, timeout, favicon }));
                        const jsonString = JSON.stringify(configOnly, null, 2);
                        const blob = new Blob([jsonString], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `interface-monitor-config_${new Date().toISOString().slice(0, 10)}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        this.addToast('配置已成功导出!', 'success');
                        console.log("配置导出成功。");
                    } catch (error) {
                        console.error("导出失败:", error);
                        this.addToast('导出配置失败!', 'error');
                    }
                },

                // 触发隐藏的文件输入框点击
                importConfigTrigger() {
                    this.$refs.fileInput.click();
                },

                // 处理文件拖放事件
                handleFileDrop(event) {
                    console.log("检测到文件拖放。");
                    this.isDraggingOver = false; // 关闭拖拽视觉效果
                    const files = event.dataTransfer.files;
                    if (files.length > 0) {
                        const file = files[0]; // 处理第一个文件
                        if (file.type === 'application/json') {
                            this.processImportFile(file); // 调用通用处理函数
                        } else {
                            this.addToast('请拖放有效的 JSON 文件 (.json)!', 'error');
                        }
                    } else {
                        console.log("拖放事件中未找到文件。");
                    }
                    event.preventDefault(); // 阻止浏览器默认行为（如打开文件）
                },

                // 处理文件输入框选择事件
                handleFileImport(event) {
                    const file = event.target.files[0];
                    if (!file) {
                        console.log("未通过输入框选择文件。");
                        event.target.value = null; // 重置输入框
                        return;
                    }
                    if (file.type !== 'application/json') {
                        this.addToast('请选择一个有效的 JSON 文件 (.json)!', 'error');
                        event.target.value = null; // 重置输入框
                        return;
                    }
                    this.processImportFile(file); // 调用通用处理函数
                    event.target.value = null; // 处理开始后重置输入框，允许再次选择同名文件
                },

                // 核心导入处理逻辑 (被拖放和点击导入共用)
                processImportFile(file) {
                    if (!file) return;
                    console.log(`正在处理导入文件: ${file.name}`);
                    const reader = new FileReader(); // 创建文件读取器

                    // 文件读取成功后的回调
                    reader.onload = async (e) => {
                        const jsonString = e.target.result; // 获取文件内容字符串
                        try {
                            const importedData = JSON.parse(jsonString); // 解析 JSON

                            // --- 数据验证 ---
                            if (!Array.isArray(importedData)) {
                                throw new Error("导入的文件内容必须是一个数组。");
                            }

                            const validatedInterfaces = []; // 存放通过验证的待导入接口
                            const importedIds = new Set(); // 用于检测导入文件内部的重复 ID

                            for (const item of importedData) {
                                // 基础验证: ID, title, url, expectedText 必须存在且类型正确
                                if (typeof item.id !== 'string' || !item.id) {
                                    console.warn("跳过缺少或无效ID的项目:", item);
                                    continue; // 跳过此项
                                }
                                if (importedIds.has(item.id)) {
                                    console.warn(`跳过导入文件中的重复ID: ${item.id} ('${item.title}')`);
                                    continue; // 跳过此项
                                }
                                if (typeof item.title !== 'string' || typeof item.url !== 'string' || typeof item.expectedText !== 'string') {
                                    console.warn(`跳过缺少必需属性(title, url, expectedText)的项目: ID ${item.id}`);
                                    continue; // 跳过此项
                                }
                                // URL 格式验证
                                try { new URL(item.url); if (!item.url.match(/^https?:\/\//i)) throw new Error(); }
                                catch { console.warn(`跳过包含无效 URL 的项目: ID ${item.id}, URL ${item.url}`); continue; }

                                // 验证通过，记录 ID 并准备数据对象
                                importedIds.add(item.id);
                                validatedInterfaces.push({
                                    id: item.id, // 保留原始 ID
                                    title: item.title,
                                    url: item.url,
                                    expectedText: item.expectedText,
                                    timeout: (typeof item.timeout === 'number' && item.timeout > 0) ? item.timeout : 3, // 设置默认超时或使用导入值
                                    favicon: item.favicon || this.getFaviconUrl(item.url), // 使用导入的 favicon 或重新生成
                                    // 初始化运行时状态
                                    status: 'pending', lastChecked: null, lastResponseTime: null, lastError: null, nextCheckInSeconds: undefined
                                });
                            }
                            // --- 验证结束 ---

                            if (validatedInterfaces.length === 0) {
                                throw new Error("文件中未找到有效的、可导入的接口配置。");
                            }

                            // --- 准备合并数据 ---
                            const existingInterfaceIds = new Set(this.interfaces.map(i => i.id)); // 获取当前所有接口的 ID 集合
                            const interfacesToAdd = []; // 最终要添加的新接口列表
                            let skippedCount = 0; // 统计因 ID 重复而跳过的数量

                            // 遍历验证后的导入数据
                            for (const newItem of validatedInterfaces) {
                                if (existingInterfaceIds.has(newItem.id)) {
                                    // 如果 ID 已存在，则跳过
                                    skippedCount++;
                                    console.log(`跳过导入已存在的 ID: ${newItem.id} ('${newItem.title}')`);
                                } else {
                                    // 如果 ID 不存在，则添加到待添加列表，并更新 existingInterfaceIds 集合以防后续重复
                                    interfacesToAdd.push(newItem);
                                    existingInterfaceIds.add(newItem.id);
                                }
                            }
                            // --- 合并准备结束 ---

                            // 如果没有可添加的新接口
                            if (interfacesToAdd.length === 0) {
                                if (skippedCount > 0) {
                                    this.addToast(`所有 ${skippedCount} 个导入的接口已存在，未添加新接口。`, 'warning');
                                    console.log("导入完成: 所有项目已存在。");
                                } else {
                                    this.addToast('在导入的文件中未找到可添加的新接口。', 'warning');
                                    console.log("导入完成: 没有有效的新项目可添加。");
                                }
                                return; // 结束导入流程
                            }

                            // --- 用户确认 (附加模式) ---
                            let confirmText = `准备添加 ${interfacesToAdd.length} 个新接口。`;
                            if (skippedCount > 0) {
                                confirmText += ` ${skippedCount} 个接口因为ID已存在而被跳过。`;
                            }
                            confirmText += " 是否继续？";

                            Swal.fire({
                                title: '确认导入?',
                                text: confirmText,
                                icon: 'info', // 附加操作使用 info 图标
                                showCancelButton: true,
                                confirmButtonColor: '#3085d6',
                                cancelButtonColor: '#d33',
                                confirmButtonText: '确认添加',
                                cancelButtonText: '取消'
                            }).then(async (result) => {
                                if (result.isConfirmed) {
                                    console.log("确认附加导入。");
                                    // 短暂停止轮询，减少并发操作
                                    this.stopPolling();
                                    this.stopUiUpdates();

                                    // --- 应用附加导入 ---
                                    try {
                                        // 1. 将新接口添加到内存数组
                                        this.interfaces.push(...interfacesToAdd);
                                        // 2. 将新接口保存到数据库 (使用 put 可以处理新增)
                                        await Promise.all(interfacesToAdd.map(iface => saveItem(INTERFACE_STORE, JSON.parse(JSON.stringify(iface)))));
                                        // 3. **不需要** 清理日志

                                        // 4. 显示成功提示
                                        let successMsg = `成功添加 ${interfacesToAdd.length} 个新接口配置!`;
                                        if (skippedCount > 0) {
                                            successMsg += ` (跳过 ${skippedCount} 个已存在的)`;
                                        }
                                        this.addToast(successMsg, 'success');
                                        console.log("附加导入成功。");

                                        // 5. 仅为新添加的接口触发一次状态检查
                                        interfacesToAdd.forEach(iface => this.checkInterfaceStatus(iface.id));

                                        // 6. 重新启动轮询和 UI 更新
                                        this.startPolling();
                                        this.startUiUpdates();

                                    } catch (dbError) {
                                        console.error("保存附加接口到数据库时出错:", dbError);
                                        this.addToast('添加导入接口时数据库操作失败!', 'error');
                                        // 考虑错误处理，例如重新加载数据以保证一致性
                                        // await this.init(); // 强制重载可能是最安全的选择
                                    }
                                    // --- 应用附加导入结束 ---
                                } else {
                                    console.log("用户取消了附加导入。");
                                }
                            });
                            // --- 用户确认结束 ---

                        } catch (parseError) {
                            // 处理 JSON 解析或文件内容验证错误
                            console.error("导入失败 - 解析或验证错误:", parseError);
                            this.addToast(`导入失败: ${parseError.message}`, 'error', 6000);
                        }
                    };

                    // 文件读取出错时的回调
                    reader.onerror = (e) => {
                        console.error("文件读取错误:", e);
                        this.addToast('读取文件时出错!', 'error');
                    };

                    reader.readAsText(file); // 开始读取文件内容
                }, // processImportFile 函数结束

                // --- UI 与辅助函数 ---
                resetNewInterfaceForm() { /* ...保持不变... */ this.newInterface = { title: '', url: '', expectedText: '', timeout: 3 }; },
                openAddModal() { /* ...保持不变... */ console.log('openAddModal called'); this.resetNewInterfaceForm(); this.$refs?.addModal?.showModal(); this.$nextTick(() => this.$refs?.addModal?.querySelector('input[type="text"]')?.focus()); },
                closeAddModal() { /* ...保持不变... */ this.$refs?.addModal?.close(); },
                openLogModal(id) { /* ...保持不变... */ this.currentLogInterfaceId = id; this.$refs?.logModal?.showModal(); },
                closeLogModal() { /* ...保持不变... */ if (this.$refs?.logModal?.open) this.$refs.logModal.close(); this.currentLogInterfaceId = null; },
                getFaviconUrl(baseUrl) { /* ...保持不变... */ try { const url = new URL(baseUrl); return `${url.protocol}//${url.hostname}/favicon.ico`; } catch (e) { return DEFAULT_FAVICON_URI; } },
                getStatusText(status) { /* ...保持不变... */ const map = { ok: '正常', error: '异常', pending: '检测中...' }; return map[status] || '待检测'; },
                formatTimestamp(timestamp) { /* ...保持不变... */ if (!timestamp) return 'N/A'; try { return new Date(timestamp).toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false }); } catch (e) { return '无效日期'; } },
                truncateUrl(url, length = 35) { /* ...保持不变... */ if (!url) return ''; return url.length > length ? url.substring(0, length) + '...' : url; },
                getInterfaceTitle(id) { /* ...保持不变... */ const iface = this.interfaces.find(i => i.id === id); return iface ? iface.title : '未知接口'; },
                getInterfaceExpectedText(id) { /* ...保持不变... */ const iface = this.interfaces.find(i => i.id === id); return iface ? (iface.expectedText === '' ? '(空)' : iface.expectedText) : 'N/A'; },
                updateNextCheckTimers() { /* ...保持不变... */ const now = Date.now(); this.interfaces.forEach(iface => { if (iface.lastChecked && iface.status !== 'pending') { const elapsed = now - iface.lastChecked; const remaining = this.pollingFrequency - elapsed; iface.nextCheckInSeconds = Math.max(0, Math.round(remaining / 1000)); } else if (iface.status !== 'pending') { iface.nextCheckInSeconds = undefined; } }); },

                // --- Toast 通知 ---
                addToast(message, type = 'info', duration = 4000) { /* ...保持不变... */ const id = crypto.randomUUID(); this.toasts.push({ id, message, type }); setTimeout(() => this.removeToast(id), duration); },
                removeToast(id) { /* ...保持不变... */ this.toasts = this.toasts.filter(t => t.id !== id); },

            } // appState 返回对象结束
        } // appState 函数结束
    </script>

</body>

</html>
