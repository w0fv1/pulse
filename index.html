<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP接口健康监控</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.12.24/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com/3.4.16"></script> <!-- 使用较新版 Tailwind -->
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <!-- 确保 Alpine 在 SweetAlert 和 Tailwind 之后加载 -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.14.9/dist/cdn.min.js"></script>
    <style>
        /* 隐藏未初始化的 Alpine 元素，防止闪烁 */
        [x-cloak] {
            display: none !important;
        }

        /* Favicon 图片样式 */
        .favicon-img {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            flex-shrink: 0;
            object-fit: contain;
        }

        /* 日志模态框内容区域样式 */
        .log-modal-content {
            max-height: 60vh;
            overflow-y: auto;
        }

        /* 卡片底部按钮间距 */
        .card-actions .btn {
            margin-left: 0.25rem;
        }

        /* 卡片标题区域布局 */
        .card-title-area {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 4px;
        }

        /* 覆盖 daisyUI 默认的卡片标题下边距 */
        .card-title-area .card-title {
            margin-bottom: 0;
        }

        /* 防止按钮组换行 */
        .card-title-area .btn-group {
            flex-shrink: 0;
        }
    </style>
</head>

<body class="bg-base-200 text-base-content min-h-screen" x-data="appState()" x-init="init()" x-cloak>

    <!-- Navbar 导航栏 -->
    <div class="navbar bg-primary text-primary-content shadow-md sticky top-0 z-50">
        <div class="flex-1">
            <a class="btn btn-ghost text-xl">接口健康监控</a>
        </div>
        <div class="flex-none gap-2">
            <!-- Network Status Indicator -->
            <div class="flex items-center mr-3 p-1 rounded-md"
                :class="isOnline ? 'bg-success/20 text-success-content' : 'bg-error/20 text-error-content'"
                title="网络状态">
                <span class="mr-1 w-5 h-5 inline-block">
                    <!-- Online Icon (Wifi) -->
                    <svg x-show="isOnline" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"
                        class="w-5 h-5">
                        <title>Online</title>
                        <path fill-rule="evenodd"
                            d="M1.37 E1.37 a2.121 2.121 0 0 1 3 0L12 12.627l7.629-7.63a2.121 2.121 0 1 1 3 3L15 15.627l7.629 7.63a2.121 2.121 0 1 1-3 3L12 18.627l-7.629 7.63a2.121 2.121 0 1 1-3-3L9 15.627 1.37 8.001a2.121 2.121 0 0 1 0-3Z"
                            clip-rule="evenodd" />
                        <path
                            d="M12.963 2.286a.75.75 0 0 0-1.071-.136 9.742 9.742 0 0 0-3.539 6.177A7.547 7.547 0 0 1 6.648 6.61a.75.75 0 0 0-1.152-.082A9 9 0 1 0 15.68 4.534a7.46 7.46 0 0 1-2.717-2.248ZM15.75 14.25a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z"
                            clip-rule="evenodd" />
                    </svg>
                    <!-- Offline Icon (Wifi off) -->
                    <svg x-show="!isOnline" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"
                        class="w-5 h-5">
                        <title>Offline</title>
                        <path
                            d="M12.987 1.505a.75.75 0 0 0-1.07-.134 10.47 10.47 0 0 0-3.774 6.583A7.55 7.55 0 0 1 6.74 6.574a.75.75 0 0 0-1.15-.082 9.01 9.01 0 0 0-.703 8.12 7.493 7.493 0 0 1 5.86 3.925.75.75 0 0 0 .93 0 7.493 7.493 0 0 1 5.86-3.926 9.01 9.01 0 0 0-.704-8.12.75.75 0 0 0-1.15.083 7.55 7.55 0 0 1-1.403 1.518 10.47 10.47 0 0 0-3.773-6.583Zm-3.143 16.88a9.017 9.017 0 0 1-4.312-3.29.75.75 0 0 1 1.008-1.114 7.52 7.52 0 0 0 6.908 0 .75.75 0 0 1 1.008 1.113 9.017 9.017 0 0 1-4.312 3.291ZM15.75 14.25a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />
                        <path fill-rule="evenodd"
                            d="M1.757 1.757a.75.75 0 0 1 1.06 0l18.43 18.43a.75.75 0 1 1-1.06 1.06L1.757 2.818a.75.75 0 0 1 0-1.06Z"
                            clip-rule="evenodd" />
                    </svg>
                </span>
                <span class="text-sm font-medium" x-text="networkStatusText"></span>
            </div>

            <!-- 应用设置按钮 -->
            <button class="btn btn-ghost" @click="openConfigModal()" title="应用设置">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                    stroke="currentColor" class="w-5 h-5 mr-1">
                    <title>配置</title>
                    <path
                        d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z" />
                </svg>
                配置
            </button>

            <!-- 导入/导出 *接口* 按钮组 -->
            <div class="dropdown dropdown-end">
                <button tabindex="0" role="button" class="btn btn-ghost">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                        stroke="currentColor" class="w-5 h-5 mr-1">
                        <title>接口配置</title>
                        <path
                            d="M10,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V8C22,6.89 21.1,6 20,6H12L10,4Z" />
                    </svg>
                    接口配置
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                        stroke="currentColor" class="w-4 h-4 ml-1">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
                    </svg>
                </button>
                <ul tabindex="0"
                    class="dropdown-content z-[1] menu p-2 shadow bg-base-100 rounded-box w-52 text-base-content">
                    <li><a @click="importConfigTrigger()">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                                stroke="currentColor" class="w-4 h-4 mr-2">
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M9 8.25H7.5a2.25 2.25 0 0 0-2.25 2.25v9a2.25 2.25 0 0 0 2.25 2.25h9a2.25 2.25 0 0 0 2.25-2.25v-9a2.25 2.25 0 0 0-2.25-2.25H15M9 12l3 3m0 0 3-3m-3 3V2.25" />
                            </svg>
                            导入接口配置 (文件)</a></li>
                    <li><a @click="openTextImportModal()">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                                stroke="currentColor" class="w-4 h-4 mr-2">
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L6.832 19.82a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.863 4.487zm0 0L19.5 7.125" />
                            </svg>
                            导入接口配置 (文本)</a></li>
                    <li><a @click="exportConfig()">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                                stroke="currentColor" class="w-4 h-4 mr-2">
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3" />
                            </svg>
                            导出接口配置 (.json)</a></li>
                </ul>
            </div>
            <!-- 新增接口 按钮 -->
            <button class="btn btn-accent" @click="openAddModal()">+ 新增接口</button>
            <!-- 隐藏的文件输入框，用于点击触发导入 -->
            <input type="file" class="hidden" x-ref="fileInput" @change="handleFileImport($event)" accept=".json">
        </div>
    </div>

    <!-- 主内容区域: 接口卡片网格 + 拖拽导入区域 -->
    <main class="p-4 md:p-6 transition-colors duration-200 relative min-h-[calc(100vh-10rem)]"
        :class="{ 'bg-primary/10 border-2 border-dashed border-primary': isDraggingOver }"
        @dragover.prevent="isDraggingOver = true" @dragleave.prevent="isDraggingOver = false"
        @drop.prevent="handleFileDrop($event)">
        <!-- 可选: 拖拽时的视觉提示遮罩层 -->
        <div x-show="isDraggingOver"
            class="absolute inset-0 flex items-center justify-center text-primary font-semibold text-lg pointer-events-none z-10">
            拖拽 .json 文件到此处导入接口配置
        </div>

        <!-- 卡片网格 -->
        <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 md:gap-6 relative z-0"
            :class="{ 'opacity-50': isDraggingOver }">

            <!-- 卡片模板 (循环渲染接口) -->
            <!-- 使用 title 作为 key -->
            <template x-for="iface in interfaces" :key="iface.title">
                <div class="card bg-base-100 shadow-xl border-t-4 min-h-[210px] flex flex-col justify-between" :class="{
                        'border-success': iface.status === 'ok',
                        'border-error': iface.status === 'error',
                        'border-warning': iface.status === 'pending',
                        'border-base-300': !iface.status || iface.status === 'offline', /* Gray border for offline */
                        'opacity-70': iface.status === 'offline' /* Slightly dim when offline */
                    }">
                    <div class="card-body p-4">
                        <div class="card-title-area mb-2">
                            <div class="flex items-center min-w-0 flex-1"><img
                                    :src="iface.favicon || DEFAULT_FAVICON_URI"
                                    @error=" (event.target.src !== DEFAULT_FAVICON_URI) event.target.src = DEFAULT_FAVICON_URI"
                                    alt="favicon" class="favicon-img">
                                <h2 class="card-title text-lg truncate" x-text="iface.title" :title="iface.title"></h2>
                            </div>
                            <div class="btn-group">
                                <!-- 传递整个接口对象到编辑模态框 -->
                                <button @click="openEditModal(iface)"
                                    class="btn btn-xs btn-ghost text-info hover:bg-info/10 p-1" title="编辑接口">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="16" height="16"
                                        viewBox="0 0 24 24">
                                        <title>编辑</title>
                                        <path
                                            d="M10 21H5C3.89 21 3 20.11 3 19V5C3 3.89 3.89 3 5 3H19C20.11 3 21 3.89 21 5V10.33C20.7 10.21 20.37 10.14 20.04 10.14C19.67 10.14 19.32 10.22 19 10.37V5H5V19H10.11L10 19.11V21M7 9H17V7H7V9M7 17H12.11L14 15.12V15H7V17M7 13H16.12L17 12.12V11H7V13M21.7 13.58L20.42 12.3C20.21 12.09 19.86 12.09 19.65 12.3L18.65 13.3L20.7 15.35L21.7 14.35C21.91 14.14 21.91 13.79 21.7 13.58M12 22H14.06L20.11 15.93L18.06 13.88L12 19.94V22Z" />
                                    </svg>
                                </button>
                                <!-- 传递 title 进行删除 -->
                                <button @click="confirmDeleteInterface(iface.title)"
                                    class="btn btn-xs btn-ghost text-error hover:bg-error/10 p-1" title="删除接口">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="16" height="16"
                                        viewBox="0 0 24 24">
                                        <title>删除</title>
                                        <path
                                            d="M9,3V4H4V6H5V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V6H20V4H15V3H9M7,6H17V19H7V6M9,8V17H11V8H9M13,8V17H15V8H13Z" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <p class="text-xs text-base-content/70 break-all mb-2" :title="iface.url"
                            x-text="truncateUrl(iface.url)"></p>
                        <div class="flex items-center text-sm mb-1">
                            <span class="mr-1 text-xl" :class="{
                                    'text-success': iface.status === 'ok',
                                    'text-error': iface.status === 'error',
                                    'text-warning': iface.status === 'pending',
                                    'text-base-content/50': !iface.status || iface.status === 'offline' /* Gray icon for offline */
                                }">
                                <span x-show="iface.status === 'ok'">✅</span>
                                <span x-show="iface.status === 'error'">❌</span>
                                <span x-show="iface.status === 'pending'"><span
                                        class="loading loading-spinner loading-xs"></span></span>
                                <span x-show="iface.status === 'offline'">⏸️</span> <!-- Pause icon for offline -->
                                <span x-show="!iface.status">-</span>
                            </span>
                            <span class="font-medium" :class="{
                                    'text-success': iface.status === 'ok',
                                    'text-error': iface.status === 'error',
                                    'text-warning': iface.status === 'pending',
                                    'text-base-content/70': !iface.status || iface.status === 'offline' /* Gray text for offline */
                                }">
                                <span x-text="getStatusText(iface.status)"></span>
                                <span x-show="iface.status === 'ok' && iface.lastResponseTime !== undefined"
                                    x-text="' (' + iface.lastResponseTime + 'ms)'"></span>
                            </span>
                        </div>
                        <p class="text-xs text-error" x-show="iface.status === 'error' && iface.lastError"
                            x-text="'原因: ' + iface.lastError"></p>
                        <!-- Show 'Network disconnected' error when offline -->
                        <p class="text-xs text-warning" x-show="iface.status === 'offline'"
                            x-text="'原因: ' + (iface.lastError || '网络已断开')"></p>
                        <p class="text-xs text-base-content/50 mt-1" x-show="iface.lastChecked"
                            x-text="'上次检测: ' + formatTimestamp(iface.lastChecked)"></p>
                        <!-- Hide 'Next check' when offline -->
                        <p class="text-xs text-base-content/50 mt-1"
                            x-show="iface.lastChecked && iface.status !== 'pending' && iface.status !== 'offline' && iface.nextCheckInSeconds !== undefined"
                            x-text="'下次检测: ' + (iface.nextCheckInSeconds > 0 ? iface.nextCheckInSeconds + ' 秒后' : '即将进行...')">
                        </p>
                    </div>
                    <div class="card-actions justify-end p-4 pt-0">
                        <!-- 传递 title 到日志模态框 -->
                        <button class="btn btn-sm btn-outline btn-info" @click="openLogModal(iface.title)">查看日志
                        </button>
                    </div>
                </div>
            </template> <!-- 卡片模板结束 -->

            <!-- 空状态占位符: 仅在没有接口且没有拖拽悬浮时显示 -->
            <div x-show="interfaces.length === 0 && !isDraggingOver"
                class="col-span-full text-center py-10 text-base-content/70">
                <div class="card bg-base-100 shadow-md p-6 inline-block">
                    <p class="mb-4">还没有监控任何接口。</p>
                    <div class="flex gap-2 justify-center">
                        <button @click="openAddModal()" class="btn btn-primary">点击添加第一个</button>
                        <button @click="importConfigTrigger()" class="btn btn-secondary">或导入接口配置</button>
                    </div>
                </div>
            </div>

        </div> <!-- 网格结束 -->
    </main>

    <!-- Add Interface Modal -->
    <dialog id="addInterfaceModal" class="modal" x-ref="addModal">
        <div class="modal-box">
            <h3 class="font-bold text-lg mb-4">新增监控接口</h3>
            <form @submit.prevent="addInterface()">
                <div class="form-control w-full mb-4"><label class="label"><span class="label-text">接口标题 (唯一标识) <span
                                class="text-error">*</span></span></label><input type="text"
                        x-model="newInterface.title" required placeholder="例如：用户API状态 (唯一)"
                        class="input input-bordered w-full" /></div>
                <div class="form-control w-full mb-4"><label class="label"><span class="label-text">接口 URL <span
                                class="text-error">*</span> (http/https)</span></label><input type="text"
                        x-model="newInterface.url" required pattern="^(https?|http)://.+"
                        placeholder="https://example.com/api/status" class="input input-bordered w-full" />
                </div>
                <div class="form-control w-full mb-4"><label class="label"><span class="label-text">预期返回包含字符 <span
                                class="text-error">*</span></span></label><input type="text"
                        x-model="newInterface.expectedText" required placeholder='例如: success, "status":"ok"'
                        class="input input-bordered w-full" /></div>
                <div class="form-control w-full mb-4"><label class="label"><span class="label-text">超时时间 (秒,
                            默认3)</span></label><input type="number" x-model.number="newInterface.timeout" min="1"
                        placeholder="3" class="input input-bordered w-full" /></div>
                <div class="modal-action">
                    <button type="button" class="btn btn-ghost" @click="closeAddModal()">取消
                    </button>
                    <button type="submit" class="btn btn-primary">确认添加</button>
                </div>
            </form>
        </div>
        <div class="modal-backdrop">
            <button @click.prevent="closeAddModal()">close</button>
        </div>
    </dialog>

    <!-- Edit Interface Modal -->
    <dialog id="editInterfaceModal" class="modal" x-ref="editModal">
        <div class="modal-box">
            <template x-if="editingInterface">
                <div>
                    <h3 class="font-bold text-lg mb-4">编辑监控接口</h3>
                    <form @submit.prevent="updateInterface()">
                        <div class="form-control w-full mb-4"><label class="label"><span class="label-text">接口标题
                                    (不可修改)</span></label>
                            <input type="text" :value="editingInterface.title" readonly disabled
                                class="input input-bordered w-full input-disabled bg-base-200/50" />
                        </div>
                        <div class="form-control w-full mb-4"><label class="label"><span class="label-text">接口 URL <span
                                        class="text-error">*</span> (http/https)</span></label><input type="text"
                                x-model="editingInterface.url" required pattern="^(https?|http)://.+"
                                placeholder="https://example.com/api/status" class="input input-bordered w-full" />
                        </div>
                        <div class="form-control w-full mb-4"><label class="label"><span class="label-text">预期返回包含字符
                                    <span class="text-error">*</span></span></label><input type="text"
                                x-model="editingInterface.expectedText" required
                                placeholder='例如: success, "status":"ok"' class="input input-bordered w-full" />
                        </div>
                        <div class="form-control w-full mb-4"><label class="label"><span class="label-text">超时时间
                                    (秒)</span></label><input type="number" x-model.number="editingInterface.timeout"
                                min="1" placeholder="3" class="input input-bordered w-full" /></div>
                        <div class="modal-action">
                            <button type="button" class="btn btn-ghost" @click="closeEditModal()">取消
                            </button>
                            <button type="submit" class="btn btn-primary">保存更改
                            </button>
                        </div>
                    </form>
                </div>
            </template>
            <div x-show="!editingInterface" class="text-center p-4"></div>
        </div>
        <div class="modal-backdrop">
            <button @click.prevent="closeEditModal()">close</button>
        </div>
    </dialog>

    <!-- Log Viewer Modal -->
    <dialog id="logModal" class="modal" x-ref="logModal">
        <div class="modal-box w-11/12 max-w-5xl">
            <div class="flex justify-between items-center mb-4">
                <h3 class="font-bold text-lg">接口日志: <span x-text="currentLogInterfaceTitle"></span></h3>
                <button @click="confirmClearLogs(currentLogInterfaceTitle)"
                    class="btn btn-sm btn-error btn-outline">清空此日志
                </button>
            </div>
            <div class="log-modal-content bg-base-200 p-2 rounded">
                <ul class="space-y-2">
                    <template x-for="log in filteredLogs()" :key="log.id">
                        <li class="p-2 rounded text-xs" :class="log.success ? 'bg-success/10' : 'bg-error/10'">
                            <div class="flex justify-between items-center mb-1"><span
                                    class="font-medium text-base-content/80"
                                    x-text="formatTimestamp(log.timestamp)"></span><span class="badge badge-sm"
                                    :class="log.success ? 'badge-success' : 'badge-error'"
                                    x-text="log.success ? '成功' : '失败'"></span>
                            </div>
                            <div class="text-base-content/70 space-y-0.5">
                                <p>URL: <code class="text-xs" x-text="log.url"></code></p>
                                <p>状态码: <span class="font-semibold" x-text="log.statusCode ?? 'N/A'"></span></p>
                                <p>响应时间: <span
                                        x-text="(log.responseTime !== null && log.responseTime !== undefined) ? log.responseTime + ' ms' : 'N/A'"></span>
                                </p>
                                <p>包含预期 (<code class="text-xs"
                                        x-text="getInterfaceExpectedText(log.interfaceTitle)"></code>): <span
                                        x-text="log.containsExpected ? '是' : '否'"></span></p>
                                <p x-show="!log.success && log.error" class="text-error font-medium">错误: <span
                                        x-text="log.error"></span></p>
                            </div>
                        </li>
                    </template>
                    <li x-show="filteredLogs().length === 0" class="text-center text-base-content/50 py-4">暂无日志记录。
                    </li>
                </ul>
            </div>
            <div class="modal-action mt-4">
                <button type="button" class="btn btn-ghost" @click="closeLogModal()">关闭
                </button>
            </div>
        </div>
        <div class="modal-backdrop">
            <button @click.prevent="closeLogModal()">close</button>
        </div>
    </dialog>

    <!-- Text Area Import Modal -->
    <dialog id="textImportModal" class="modal" x-ref="textImportModal">
        <div class="modal-box">
            <h3 class="font-bold text-lg mb-4">通过文本导入接口配置</h3>
            <p class="text-sm text-base-content/70 mb-4">
                请在下方粘贴 JSON 格式的接口配置数组。导入将<strong class="text-warning">合并</strong>到现有配置中 (Title
                相同的将更新，不同的将新增)。<strong class="text-error">Title 是唯一标识，不能重复。</strong>
            </p>
            <form @submit.prevent="handleTextInputImport">
                <div class="form-control">
                    <textarea class="textarea textarea-bordered h-48 font-mono text-sm" x-ref="importTextArea"
                        placeholder='[
    {
        "title": "我的 API 1 (必须, 唯一)",
        "url": "https://example.com/api/status1",
        "expectedText": "success",
        "timeout": 5,
        "favicon": "data:image/png;base64,..." // 可选
    },
    {
        "title": "我的 API 2 (必须, 唯一)",
        "url": "https://example.com/api/status2",
        "expectedText": "\"status\":\"ok\"",
        "timeout": 3
    }
]'></textarea>
                    <label class="label">
                        <span class="label-text-alt text-error" x-show="importTextError"
                            x-text="importTextError"></span>
                    </label>
                </div>
                <div class="modal-action">
                    <button type="button" class="btn btn-ghost" @click="closeTextImportModal()">取消</button>
                    <button type="submit" class="btn btn-primary">确认导入</button>
                </div>
            </form>
        </div>
        <div class="modal-backdrop">
            <button @click.prevent="closeTextImportModal()">close</button>
        </div>
    </dialog>

    <!-- Config Edit Modal -->
    <dialog id="configModal" class="modal" x-ref="configModal">
        <div class="modal-box">
            <h3 class="font-bold text-lg mb-4">应用设置</h3>
            <form @submit.prevent="saveAppConfig()">
                <div class="form-control w-full mb-4">
                    <label class="label"><span class="label-text">全局轮询间隔 (秒)</span></label>
                    <input type="number" x-model.number="currentConfig.pollingFrequencySeconds" required min="1"
                        class="input input-bordered w-full" />
                    <label class="label">
                        <span class="label-text-alt">每次检查所有接口的频率</span>
                    </label>
                </div>
                <div class="form-control w-full mb-4">
                    <label class="label"><span class="label-text">每个接口保留的最大日志条数</span></label>
                    <input type="number" x-model.number="currentConfig.maxLogsPerInterface" required min="1" max="1000"
                        class="input input-bordered w-full" />
                    <label class="label">
                        <span class="label-text-alt">超过此数量的最旧日志将被自动删除</span>
                    </label>
                </div>
                <div class="modal-action">
                    <button type="button" class="btn btn-ghost" @click="closeConfigModal()">取消</button>
                    <button type="submit" class="btn btn-primary">保存设置</button>
                </div>
            </form>
        </div>
        <div class="modal-backdrop">
            <button @click.prevent="closeConfigModal()">close</button>
        </div>
    </dialog>

    <!-- Toast Notifications Area -->
    <div class="toast toast-top toast-end z-[9999]">
        <template x-for="toast in toasts" :key="toast.id">
            <div :class="['alert', toast.type === 'error' ? 'alert-error' : (toast.type === 'success' ? 'alert-success' : 'alert-warning'), 'shadow-lg', 'cursor-pointer']"
                @click="removeToast(toast.id)">
                <div class="flex-1"><span class="text-sm" x-text="toast.message"></span></div>
            </div>
        </template>
    </div>

    <!-- JavaScript 核心逻辑 -->
    <script>
        // --- 常量定义 ---
        const DEFAULT_FAVICON_URI = "data:image/svg+xml;charset=utf-8;base64,PHN2ZyB0PSIxNzQ1MTQ1MTQ4ODA4IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjI3NTgiIHdpZHRoPSIyNTYiIGhlaWdodD0iMjU2Ij48cGF0aCBkPSJNNTEyIDMyQzI0Ni45MTIgMzIgMzIgMjQ2Ljg0OCAzMiA1MTJzMjE0LjkxMiA0ODAgNDgwIDQ4MGMyNjUuMTUyIDAgNDgwLTIxNC44NDggNDgwLTQ4MFM3NzcuMTUyIDMyIDUxMiAzMnpNMzIwLjI1NiAxNDMuMDRjMjAuODY0LTEwLjg4IDQyLjY4OC0yMC4xNiA2NS40MDgtMjcuMzkyLTIzLjYxNiAzNC42MjQtNDMuOTY4IDc4LjY1Ni01OS45MDQgMTI5LjYtMjMuODA4LTE1LjIzMi0zNy43Ni0zMy40NzItMzcuNzYtNTMuMjQ4IDAtMTcuOTg0IDEyLjIyNC0zNC41NiAzMi4yNTYtNDguOTZ6TTIyNy4xMzYgMjA5LjM0NGM3LjQyNCAzNy41NjggMzYuODY0IDcxLjI5NiA4Mi43NTIgOTYuNTEyLTExLjg0IDUzLjM3Ni0xOS4yIDExMi4wNjQtMjEuMTIgMTc0LjE0NEg5Ny42YTQxNC40NjQgNDE0LjQ2NCAwIDAgMSAxMjkuNTM2LTI3MC42NTZ6IG0wIDYwNS4zMTJBNDE0LjQ2NCA0MTQuNDY0IDAgMCAxIDk3LjYgNTQ0aDE5MS4xMDRjMS45MiA2Mi4wOCA5LjM0NCAxMjAuNzY4IDIxLjE4NCAxNzQuMTQ0LTQ1Ljg4OCAyNS4wODgtNzUuMzI4IDU4Ljk0NC04Mi43NTIgOTYuNTEyeiBtOTMuMTIgNjYuMzA0QzMwMC4yMjQgODY2LjU2IDI4OCA4NDkuOTIgMjg4IDgzMmMwLTE5Ljc3NiAxMy45NTItMzguMDggMzcuNzYtNTMuMzEyIDE1LjkzNiA1MS4wMDggMzYuMjg4IDk0Ljk3NiA1OS45MDQgMTI5LjY2NGE0MTEuMzkyIDQxMS4zOTIgMCAwIDEtNjUuNDA4LTI3LjM5MnogbTE1OS43NDQgMzguNjU2Yy00MC4xOTItMjEuMTg0LTc0LjgyNi04MS44NTYtOTcuOTItMTY1LjU2OGE0MjUuNTM2IDQyNS41MzYgMCAwIDEgOTcuOTItMTYuNzA0djE4Mi4yNzJ6IG0wLTI0NS44MjRhNDU0LjU5MiA0NTQuNTkyIDAgMCAwLTExMS42OCAyMC4yODhBOTY2LjQgOTY2LjQgMCAwIDEgMzUyLjY0IDU0NEg0ODB2MTI5Ljc5MnogbTAtMTkzLjc5MkgzNTIuNjRhOTY2LjQgOTY2LjQgMCAwIDEgMTUuNjgtMTUwLjA4IDQ2MC42MDggNDYwLjYwOCAwIDAgMCAxMTEuNjggMjAuMzUyVjQ4MHogbTAtMTkzLjM0NGE0MzIuNTEyIDQzMi41MTIgMCAwIDEtOTcuOTItMTYuNzA0YzIzLjEwNC04My43MTIgNTcuNzI4LTE0NC4zMiA5Ny45Mi0xNjUuNTY4djE4Mi4yNzJ6IG0zMTYuODY0LTc3LjMxMkE0MTQuMDggNDE0LjA4IDAgMCAxIDkyNi4zMzYgNDgwaC0xOTEuMTA0Yy0xLjkyLTYyLjA4LTkuMzQ0LTEyMC43NjgtMjEuMTg0LTE3NC4xNDQgNDUuOTUyLTI1LjE1MiA3NS4zOTItNTguOTQ0IDgyLjgxNi05Ni41MTJ6IG0tOTMuMTItNjYuMzA0YzIwLjAzMiAxNC40IDMyLjI1NiAzMC45NzYgMzIuMjU2IDQ4Ljk2IDAgMTkuNzc2LTEzLjk1MiAzOC4wMTYtMzcuNzYgNTMuMjQ4LTE1LjkzNi01MC45NDQtMzYuMjg4LTk0Ljk3Ni01OS45NjgtMTI5LjZhNDA5LjYgNDA5LjYgMCAwIDEgNjUuNDcyIDI3LjM5MnpNNTQ0IDEwNC4zODRjNDAuMjU2IDIxLjI0OCA3NC44OCA4MS44NTYgOTcuOTIgMTY1LjU2OGE0MzIuNTEyIDQzMi41MTIgMCAwIDEtOTcuOTIgMTYuNzA0VjEwNC4zODR6IG0wIDI0NS44ODhhNDYwLjA5NiA0NjAuMDk2IDAgMCAwIDExMS42OC0yMC4yODhjOC42NCA0NS44ODggMTQuMTQ0IDk2LjQ0OCAxNS42OCAxNTAuMDE2SDU0NFYzNTAuMjcyeiBtMCAxOTMuNzI4aDEyNy4zNmMtMS41MzYgNTMuNTY4LTcuMDQgMTA0LjEyOC0xNS42OCAxNTAuMTQ0YTQ1NC4wMTYgNDU0LjAxNiAwIDAgMC0xMTEuNjgtMjAuMjg4VjU0NHogbTAgMzc1LjYxNnYtMTgyLjI3MmE0MjUuNTM2IDQyNS41MzYgMCAwIDEgOTcuOTIgMTYuNzA0Yy0yMy4wNCA4My43MTItNTcuNjY0IDE0NC4zODQtOTcuOTIgMTY1LjU2OHogbTE1OS43NDQtMzguNjU2Yy0yMC44NjQgMTAuODgtNDIuNjg4IDIwLjE2LTY1LjQwOCAyNy40NTYgMjMuNjE2LTM0LjY4OCA0NC4wMzItNzguNjU2IDU5Ljk2OC0xMjkuNjY0IDIzLjgwOCAxNS4yMzIgMzcuNzYgMzMuNTM2IDM3Ljc2IDUzLjMxMi0wLjA2NCAxNy44NTYtMTIuMjg4IDM0LjQ5Ni0zMi4zMiA0OC44OTZ6IG05My4xMi02Ni4zMDRjLTcuNDI0LTM3LjU2OC0zNi45MjgtNzEuMzYtODIuODE2LTk2LjUxMmE5MzYuOTYgOTM2Ljk2IDAgMCAwIDIxLjE4NC0xNzQuMTQ0aDE5MS4xMDRhNDE0LjA4IDQxNC4wOCAwIDAgMS0xMjkuNDcyIDI3MC42NTZ6IiBmaWxsPSJjdXJyZW50Q29sb3IiIHAtaWQ9IjI3NTkiPjwvcGF0aD48L3N2Zz4=";
        const PROXY_BASE_URL = 'https://cors-proxy.wofbi233.workers.dev/';
        const DB_VERSION = 3;

        // --- IndexedDB 管理类 (保持不变) ---
        class IndexedDBManager {
            constructor(dbName = 'InterfaceMonitorDB_v4', dbVersion = DB_VERSION) { // 使用常量版本
                this.dbName = dbName;
                this.dbVersion = dbVersion;
                this.INTERFACE_STORE = 'interfaces';
                this.LOG_STORE = 'logs';
                this.CONFIG_STORE = 'config'; // 新增 config 存储名称
                this.db = null;
            }

            _openDB() {
                return new Promise((resolve, reject) => {
                    // 如果数据库已打开且版本正确，直接返回
                    if (this.db && this.db.version === this.dbVersion) {
                        resolve(this.db);
                        return;
                    }
                    // 否则，打开数据库
                    const request = indexedDB.open(this.dbName, this.dbVersion);

                    request.onerror = (event) => {
                        console.error("IndexedDB 错误:", request.error);
                        reject("IndexedDB 错误: " + request.error?.message);
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        // 添加错误和关闭处理
                        this.db.onerror = (event) => {
                            console.error(`数据库错误: ${event.target.error?.message || event.target.error}`);
                        };
                        this.db.onclose = () => {
                            console.warn("数据库连接已关闭。");
                            this.db = null; // 清除引用
                        };
                        resolve(this.db);
                    };

                    // 数据库升级或首次创建时调用
                    request.onupgradeneeded = (event) => {
                        console.log(`需要 IndexedDB 升级，从版本 ${event.oldVersion} 到 ${event.newVersion}...`);
                        const db = event.target.result;
                        const transaction = event.target.transaction;

                        // --- 接口存储 (Interfaces Store) ---
                        if (db.objectStoreNames.contains(this.INTERFACE_STORE)) {
                            if (!transaction.objectStore(this.INTERFACE_STORE).keyPath === 'title') {
                                console.log(`删除现有对象存储: ${this.INTERFACE_STORE} 以更新 keyPath。`);
                                db.deleteObjectStore(this.INTERFACE_STORE);
                                console.log(`创建对象存储: ${this.INTERFACE_STORE}，keyPath 为 'title'。`);
                                db.createObjectStore(this.INTERFACE_STORE, { keyPath: 'title' });
                            } else {
                                console.log(`对象存储 ${this.INTERFACE_STORE} 已存在且 keyPath 正确。`);
                            }
                        } else {
                            console.log(`创建对象存储: ${this.INTERFACE_STORE}，keyPath 为 'title'。`);
                            db.createObjectStore(this.INTERFACE_STORE, { keyPath: 'title' }); // 使用 'title' 作为主键
                        }


                        // --- 日志存储 (Logs Store) ---
                        if (!db.objectStoreNames.contains(this.LOG_STORE)) {
                            console.log(`创建对象存储: ${this.LOG_STORE}，keyPath 为 'id'。`);
                            const logStore = db.createObjectStore(this.LOG_STORE, { keyPath: 'id' }); // 日志 ID 仍然是 UUID
                            console.log(`在 ${this.LOG_STORE} 上创建索引 'interfaceTitle'。`);
                            logStore.createIndex('interfaceTitle', 'interfaceTitle', { unique: false }); // 索引存储接口标题
                            console.log(`在 ${this.LOG_STORE} 上创建索引 'timestamp'。`);
                            logStore.createIndex('timestamp', 'timestamp', { unique: false });
                        } else {
                            console.log(`对象存储 ${this.LOG_STORE} 已存在。`);
                            // 检查并创建可能缺失的索引 (升级时可能需要)
                            if (transaction && transaction.objectStore) {
                                const logStore = transaction.objectStore(this.LOG_STORE);
                                if (!logStore.indexNames.contains('interfaceTitle')) {
                                    console.log(`在 ${this.LOG_STORE} 上创建缺失的索引 'interfaceTitle'。`);
                                    logStore.createIndex('interfaceTitle', 'interfaceTitle', { unique: false });
                                }
                                if (!logStore.indexNames.contains('timestamp')) {
                                    console.log(`在 ${this.LOG_STORE} 上创建缺失的索引 'timestamp'。`);
                                    logStore.createIndex('timestamp', 'timestamp', { unique: false });
                                }
                            }
                        }

                        // --- 应用配置存储 (Config Store) --- 新增
                        if (!db.objectStoreNames.contains(this.CONFIG_STORE)) {
                            console.log(`创建对象存储: ${this.CONFIG_STORE}，keyPath 为 'id'。`);
                            // 使用 'id' 作为 keyPath，通常会存入一个 id 为 'appConfig' 的单条记录
                            db.createObjectStore(this.CONFIG_STORE, { keyPath: 'id' });
                        } else {
                            console.log(`对象存储 ${this.CONFIG_STORE} 已存在。`);
                        }

                        console.log('IndexedDB 升级完成。');
                    };
                });
            }

            // 封装通用的数据库操作
            _dbAction(storeName, mode, action) {
                return this._openDB().then(db => {
                    return new Promise((resolve, reject) => {
                        // 检查 store 是否存在
                        if (!db.objectStoreNames.contains(storeName)) {
                            return reject(`对象存储 "${storeName}" 未找到。`);
                        }
                        let transaction;
                        try {
                            // 开启事务
                            transaction = db.transaction(storeName, mode);
                            const store = transaction.objectStore(storeName);
                            let requestCompleted = false; // 标记请求是否完成

                            // 事务完成回调
                            transaction.oncomplete = () => {
                                if (!requestCompleted) resolve(); // 如果 action 没有 resolve，在这里 resolve
                            };
                            // 事务错误回调
                            transaction.onerror = (event) => {
                                console.error(`事务错误 (${storeName}, ${mode}):`, event.target.error);
                                reject(`事务错误: ${event.target.error?.message || event.target.error}`);
                            };
                            // 事务中止回调
                            transaction.onabort = (event) => {
                                console.warn(`事务中止 (${storeName}, ${mode}):`, event.target.error);
                                reject(`事务中止: ${event.target.error?.message || 'Aborted'}`);
                            };

                            // 执行具体操作
                            action(store, (result) => { // 成功回调
                                requestCompleted = true;
                                resolve(result);
                            }, (error) => { // 失败回调
                                requestCompleted = true;
                                reject(error);
                            }, transaction); // 传递事务对象

                        } catch (error) {
                            console.error(`启动事务失败 (${storeName}, ${mode}):`, error);
                            reject(`启动事务失败: ${error?.message || error}`);
                        }
                    });
                }).catch(err => {
                    // 捕获 _openDB 或 Promise 链中的错误
                    console.error(`IndexedDB 操作失败 (${storeName}):`, err);
                    throw err; // 重新抛出错误
                });
            }

            // 获取指定 store 的所有项目
            getAll(storeName) {
                return this._dbAction(storeName, 'readonly', (store, resolve, reject) => {
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            }

            // 通过 key 获取单个项目
            getItem(storeName, key) {
                return this._dbAction(storeName, 'readonly', (store, resolve, reject) => {
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result); // result 可能是 undefined 如果 key 不存在
                    request.onerror = (event) => reject(event.target.error);
                });
            }

            // 保存或更新项目 (put 会根据 keyPath 自动判断是新增还是更新)
            saveItem(storeName, item) {
                return this._dbAction(storeName, 'readwrite', (store, resolve, reject) => {
                    const request = store.put(item);
                    request.onsuccess = () => resolve(request.result); // 返回 key
                    request.onerror = (event) => reject(event.target.error);
                });
            }

            // 通过 key 删除项目 (对于 interfaces, key 是 title)
            deleteItem(storeName, key) {
                return this._dbAction(storeName, 'readwrite', (store, resolve, reject) => {
                    const request = store.delete(key);
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            }

            // 通过接口标题 (interfaceTitle) 删除相关日志
            deleteLogsByInterfaceTitle(interfaceTitle) {
                return this._dbAction(this.LOG_STORE, 'readwrite', (store, resolve, reject) => {
                    try {
                        // 使用存储标题的索引
                        const index = store.index('interfaceTitle');
                        const request = index.openKeyCursor(IDBKeyRange.only(interfaceTitle));
                        const keysToDelete = []; // 存储日志的 UUID (主键)

                        request.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor) {
                                keysToDelete.push(cursor.primaryKey); // 主键仍然是 log 的 UUID
                                cursor.continue();
                            } else {
                                // 游标结束，开始删除
                                if (keysToDelete.length === 0) {
                                    resolve(0); // 没有日志需要删除
                                    return;
                                }
                                let deleteCount = 0;
                                // 为每个 key 创建一个删除 Promise
                                let promises = keysToDelete.map(key => {
                                    return new Promise((res, rej) => {
                                        try {
                                            const deleteRequest = store.delete(key);
                                            deleteRequest.onsuccess = () => { deleteCount++; res(); };
                                            deleteRequest.onerror = (e) => rej(e.target.error);
                                        } catch (delErr) { rej(delErr); }
                                    });
                                });
                                // 等待所有删除完成
                                Promise.all(promises).then(() => resolve(deleteCount)).catch(reject);
                            }
                        };
                        request.onerror = (event) => reject(event.target.error);
                    } catch (indexErr) {
                        reject(`访问索引 'interfaceTitle' 失败 (${this.LOG_STORE}): ${indexErr.message}`);
                    }
                });
            }

            // 保存单条日志记录
            saveLog(logData) {
                return this._dbAction(this.LOG_STORE, 'readwrite', (store, resolve, reject) => {
                    // 确保日志有 ID 和 interfaceTitle
                    if (!logData.id) { logData.id = crypto.randomUUID(); }
                    if (typeof logData.interfaceTitle !== 'string') {
                        return reject("日志数据必须包含 interfaceTitle 字符串。");
                    }
                    const addRequest = store.add(logData); // 使用 add，如果 id 重复会报错 (不太可能用 UUID)
                    addRequest.onsuccess = resolve;
                    addRequest.onerror = (e) => reject(e.target.error);
                });
            }

            // 修剪指定接口 (interfaceTitle) 的旧日志，只保留最新的 maxKept 条
            pruneOldLogs(interfaceTitle, maxKept) {
                return this._dbAction(this.LOG_STORE, 'readwrite', (store, resolve, reject, transaction) => {
                    try {
                        // 获取需要的索引
                        const timestampIndex = store.index('timestamp');
                        const titleIndex = store.index('interfaceTitle');
                        const range = IDBKeyRange.only(interfaceTitle); // 只查询指定接口的日志
                        const logsMeta = []; // 存储 {key: logId, timestamp: logTimestamp}

                        // 1. 使用 interfaceTitle 索引获取该接口所有日志的主键和时间戳
                        titleIndex.openCursor(range).onsuccess = event => {
                            const cursor = event.target.result;
                            if (cursor) {
                                // 收集日志的 primaryKey (UUID) 和 timestamp
                                logsMeta.push({ key: cursor.primaryKey, timestamp: cursor.value.timestamp });
                                cursor.continue();
                            } else {
                                // 2. 游标结束，所有日志元数据收集完毕
                                if (logsMeta.length <= maxKept) {
                                    resolve(0); // 日志数量未超限，无需清理
                                    return;
                                }

                                // 3. 按时间戳降序排序，找到需要删除的旧日志
                                logsMeta.sort((a, b) => b.timestamp - a.timestamp); // 新的在前

                                // 4. 获取超过 maxKept 数量的日志的主键 (这些是旧的)
                                const keysToDelete = logsMeta.slice(maxKept).map(item => item.key);

                                // 5. 执行删除操作
                                let deletePromises = keysToDelete.map(logId => new Promise((res, rej) => {
                                    try {
                                        // 使用 store 对象进行删除
                                        const delReq = store.delete(logId);
                                        delReq.onsuccess = res;
                                        delReq.onerror = e => rej(e.target.error);
                                    } catch (delErr) { rej(delErr); }
                                }));
                                // 等待所有删除完成
                                Promise.all(deletePromises)
                                    .then(() => resolve(keysToDelete.length)) // 返回删除的数量
                                    .catch(reject);
                            }
                        };
                        titleIndex.openCursor(range).onerror = event => reject(event.target.error);

                    } catch (indexErr) {
                        reject(`访问日志索引失败 (${this.LOG_STORE}): ${indexErr.message}`);
                    }
                });
            }

            // 清空指定的 store
            clearStore(storeName) {
                return this._dbAction(storeName, 'readwrite', (store, resolve, reject) => {
                    const request = store.clear();
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            }
        }
        // --- End IndexedDB Manager ---


        // --- 代理 Fetch 函数 (保持不变) ---
        async function fetchThroughProxy({ url, method = 'GET', query = {}, body = null, headers = {}, signal }) {
            if (!url) throw new Error('目标URL是必需的');
            const urlObject = new URL(url);
            // 添加查询参数
            Object.entries(query).forEach(([key, value]) => urlObject.searchParams.append(key, value));
            const targetUrl = urlObject.toString();

            // 构建代理请求 URL
            const proxyUrl = new URL(PROXY_BASE_URL);
            proxyUrl.searchParams.append('url', targetUrl); // 将目标 URL 作为参数传递给代理

            // 准备 fetch 选项
            const fetchOptions = {
                method,
                headers: { ...headers, 'Accept': 'application/json, text/plain, */*' }, // 默认接受类型
                signal, // 用于中止请求 (超时)
                // 只有在非 GET/HEAD 请求且有 body 时才添加 body
                body: (method !== 'GET' && method !== 'HEAD' && body) ? (typeof body === 'string' ? body : JSON.stringify(body)) : null,
            };
            // 如果 body 是对象且没有指定 Content-Type，默认为 JSON
            if (fetchOptions.body && typeof body === 'object' && !headers['Content-Type']) {
                fetchOptions.headers['Content-Type'] = 'application/json';
            }

            // 发起代理请求
            const response = await fetch(proxyUrl.toString(), fetchOptions);
            return response;
        }

        // --- Alpine.js 应用状态定义 ---
        function appState() {
            return {
                // --- 核心状态数据 ---
                interfaces: [], // 监控的接口列表
                logs: [],       // 所有接口的日志记录 (内存缓存)
                // 新增接口表单模型
                newInterface: { title: '', url: '', expectedText: '', timeout: 3 },
                editingInterface: null, // 当前正在编辑的接口对象
                currentLogInterfaceTitle: null, // 当前查看日志的接口标题
                isDraggingOver: false,  // 是否有文件拖拽到页面上
                importTextError: null, // 文本导入时的错误信息
                db: null,             // IndexedDB 管理器实例

                // --- 应用配置项 ---
                pollingFrequency: 15000, // 全局轮询间隔 (ms) - 默认值
                maxLogsPerInterface: 100, // 每个接口最大日志数 - 默认值
                pollingInterval: null,   // 轮询定时器 ID
                uiUpdateInterval: null, // UI 更新定时器 ID

                // --- 应用配置编辑模态框状态 ---
                currentConfig: { // 用于模态框编辑的数据模型
                    pollingFrequencySeconds: 15,
                    maxLogsPerInterface: 100
                },

                // --- Toast 通知 ---
                toasts: [],

                // --- 网络状态 ---
                isOnline: navigator.onLine, // 初始化网络状态
                networkStatusText: '',    // 显示的文本 (在线/离线)

                // --- 常量 ---
                INTERFACE_STORE_NAME: 'interfaces',
                LOG_STORE_NAME: 'logs',
                CONFIG_STORE_NAME: 'config',
                CONFIG_KEY: 'appConfig',

                // --- 生命周期钩子 & 初始化 ---
                async init() {
                    console.log('应用初始化...');
                    this.db = new IndexedDBManager(); // 创建 DB 管理器

                    // 设置初始网络状态文本
                    this.updateNetworkStatusText();
                    // 监听网络状态变化
                    window.addEventListener('offline', () => this.handleOffline());
                    window.addEventListener('online', () => this.handleOnline());

                    try {
                        // 1. 加载应用配置
                        await this.loadAppConfig();

                        // 2. 加载接口列表和日志
                        this.interfaces = await this.db.getAll(this.INTERFACE_STORE_NAME);
                        this.logs = await this.db.getAll(this.LOG_STORE_NAME);
                        console.log(`加载了 ${this.interfaces.length} 个接口, ${this.logs.length} 条日志。`);

                        // 3. 处理 URL 导入参数
                        const urlParams = new URLSearchParams(window.location.search);
                        const importUrl = urlParams.get('import');
                        let urlImportPromise = Promise.resolve();
                        if (importUrl) {
                            console.log(`发现导入 URL 参数: ${importUrl}`);
                            urlImportPromise = this.importFromUrl(importUrl).catch(err => {
                                console.error("URL 导入失败:", err);
                                this.addToast(`从 URL 导入失败: ${err.message}`, 'error', 6000);
                            });
                        }
                        await urlImportPromise;

                        // 4. 添加默认示例 (如果需要)
                        if (this.interfaces.length === 0 && !importUrl) {
                            console.log("未发现接口且无 URL 导入，添加默认示例...");
                            const defaultIface = {
                                title: '示例接口 (Example.com)',
                                url: 'https://example.com/',
                                expectedText: 'Example Domain',
                                timeout: 5,
                                favicon: this.getFaviconUrl('https://example.com/'),
                                status: 'pending', // 初始状态
                                lastChecked: null, lastResponseTime: null, lastError: null,
                                nextCheckInSeconds: undefined
                            };
                            this.interfaces.push(defaultIface);
                            await this.saveInterfaces();
                            this.addToast('已添加一个示例接口，您可以编辑或删除它', 'info', 6000);
                        }

                        // 5. 初始化接口状态
                        this.interfaces.forEach(iface => {
                            // 如果当前离线，将所有状态设置为 offline，否则设置为 pending 或保持现有
                            if (!this.isOnline) {
                                iface.status = 'offline';
                                iface.lastError = '网络已断开';
                            } else {
                                if (!iface.status || iface.status === 'offline') iface.status = 'pending'; // 如果之前是 offline，重置为 pending
                            }
                            if (!iface.favicon) iface.favicon = this.getFaviconUrl(iface.url);
                            if (typeof iface.timeout !== 'number' || iface.timeout <= 0) iface.timeout = 3;
                            iface.nextCheckInSeconds = undefined;
                        });

                        // 6. 仅在在线时启动轮询和 UI 更新
                        if (this.isOnline) {
                            this.startPolling();
                            this.startUiUpdates();
                        } else {
                            console.warn("当前处于离线状态，监控未启动。");
                            this.addToast('当前离线，监控将在网络恢复后开始。', 'warning');
                        }
                        console.log('初始化完成。');

                    } catch (error) {
                        console.error("初始化失败:", error);
                        if (error && error.message && error.message.includes('object store') && (error.message.includes('key path') || error.message.includes('index'))) {
                            this.addToast(`数据库结构错误: ${error.message}. 可能需要清除浏览器缓存或应用数据后重试。`, 'error', 10000);
                        } else {
                            this.addToast(`加载本地数据失败: ${error.message || error}`, 'error');
                        }
                    }
                },

                // --- 网络状态处理 ---
                updateNetworkStatusText() {
                    this.networkStatusText = this.isOnline ? '在线' : '离线';
                },
                handleOffline() {
                    if (!this.isOnline) return; // Already offline
                    console.warn('网络连接丢失，暂停监控。');
                    this.isOnline = false;
                    this.updateNetworkStatusText();
                    this.stopPolling();
                    this.stopUiUpdates(); // Also stop UI updates timer
                    // Update all cards to 'offline' status
                    this.interfaces.forEach(iface => {
                        this.updateInterfaceState(iface.title, { status: 'offline', lastError: '网络已断开', nextCheckInSeconds: undefined });
                    });
                    this.addToast('网络连接已断开，监控暂停。', 'warning');
                },
                handleOnline() {
                    if (this.isOnline) return; // Already online
                    console.log('网络连接恢复，将刷新页面以重新开始监控。');
                    this.isOnline = true; // Update state immediately
                    this.updateNetworkStatusText();
                    this.addToast('网络连接已恢复，正在刷新应用...', 'success', 2500); // Give user time to see message
                    // Reload the page after a short delay to ensure clean state
                    setTimeout(() => {
                        window.location.reload();
                    }, 1000); // Delay before reloading
                    // Note: An alternative to reloading would be to set all 'offline' statuses
                    // back to 'pending' and call startPolling() / startUiUpdates().
                    // Reloading is simpler to guarantee a fresh start as requested.
                },

                // --- 应用配置管理 (保持不变) ---
                async loadAppConfig() {
                    try {
                        let config = await this.db.getItem(this.CONFIG_STORE_NAME, this.CONFIG_KEY);
                        if (config) {
                            this.pollingFrequency = config.pollingFrequency || 15000;
                            this.maxLogsPerInterface = config.maxLogsPerInterface || 100;
                            console.log(`已加载应用配置: 轮询间隔 ${this.pollingFrequency}ms, 最大日志 ${this.maxLogsPerInterface}条`);
                        } else {
                            console.log(`未找到应用配置，使用默认值并保存。`);
                            this.pollingFrequency = 15000;
                            this.maxLogsPerInterface = 100;
                            await this.db.saveItem(this.CONFIG_STORE_NAME, {
                                id: this.CONFIG_KEY,
                                pollingFrequency: this.pollingFrequency,
                                maxLogsPerInterface: this.maxLogsPerInterface
                            });
                        }
                        this.currentConfig.pollingFrequencySeconds = this.pollingFrequency / 1000;
                        this.currentConfig.maxLogsPerInterface = this.maxLogsPerInterface;
                    } catch (error) {
                        console.error("加载应用配置失败:", error);
                        this.addToast('加载应用设置失败，将使用默认值。', 'warning');
                        this.pollingFrequency = 15000;
                        this.maxLogsPerInterface = 100;
                        this.currentConfig.pollingFrequencySeconds = 15;
                        this.currentConfig.maxLogsPerInterface = 100;
                    }
                },
                openConfigModal() {
                    this.currentConfig.pollingFrequencySeconds = this.pollingFrequency / 1000;
                    this.currentConfig.maxLogsPerInterface = this.maxLogsPerInterface;
                    this.$refs?.configModal?.showModal();
                    this.$nextTick(() => this.$refs?.configModal?.querySelector('input[type="number"]')?.focus());
                },
                closeConfigModal() {
                    if (this.$refs?.configModal?.open) this.$refs.configModal.close();
                },
                async saveAppConfig() {
                    const newPollingSeconds = parseInt(this.currentConfig.pollingFrequencySeconds, 10);
                    const newMaxLogs = parseInt(this.currentConfig.maxLogsPerInterface, 10);

                    if (isNaN(newPollingSeconds) || newPollingSeconds < 1) {
                        this.addToast('轮询间隔必须是大于等于 1 的数字!', 'error'); return;
                    }
                    if (isNaN(newMaxLogs) || newMaxLogs < 1 || newMaxLogs > 1000) {
                        this.addToast('最大日志条数必须是 1 到 1000 之间的数字!', 'error'); return;
                    }

                    const newPollingFrequencyMs = newPollingSeconds * 1000;
                    const configChanged = newPollingFrequencyMs !== this.pollingFrequency || newMaxLogs !== this.maxLogsPerInterface;

                    if (configChanged) {
                        console.log('应用配置已更改，正在保存...');
                        const oldFrequency = this.pollingFrequency;
                        this.pollingFrequency = newPollingFrequencyMs;
                        this.maxLogsPerInterface = newMaxLogs;

                        try {
                            await this.db.saveItem(this.CONFIG_STORE_NAME, {
                                id: this.CONFIG_KEY,
                                pollingFrequency: this.pollingFrequency,
                                maxLogsPerInterface: this.maxLogsPerInterface
                            });
                            this.addToast('应用设置已保存!', 'success');

                            if (newPollingFrequencyMs !== oldFrequency && this.isOnline) { // Restart polling only if online
                                console.log(`轮询间隔更改，重启轮询。`);
                                this.stopPolling();
                                this.startPolling();
                            }
                        } catch (error) {
                            console.error("保存应用配置失败:", error);
                            this.addToast('保存应用设置失败!', 'error');
                        }
                    } else {
                        this.addToast('设置未更改。', 'info');
                    }
                    this.closeConfigModal();
                },


                // --- 轮询控制 ---
                startPolling() {
                    // Only start if online
                    if (!this.isOnline) {
                        console.log("Cannot start polling: Offline.");
                        return;
                    }
                    if (this.pollingInterval) clearInterval(this.pollingInterval);
                    if (this.interfaces.length === 0) return;
                    console.log(`启动轮询: 使用间隔 ${this.pollingFrequency}ms`);
                    this.checkAllInterfaces(); // 立即检查一次 (if online)
                    this.pollingInterval = setInterval(() => this.checkAllInterfaces(), this.pollingFrequency);
                },
                stopPolling() {
                    if (this.pollingInterval) {
                        clearInterval(this.pollingInterval);
                        this.pollingInterval = null;
                        console.log('轮询已停止。');
                    }
                },
                startUiUpdates() {
                    if (!this.isOnline) {
                        console.log("Cannot start UI updates: Offline.");
                        return;
                    }
                    if (this.uiUpdateInterval) clearInterval(this.uiUpdateInterval);
                    this.uiUpdateInterval = setInterval(() => this.updateNextCheckTimers(), 1000);
                    console.log('UI 更新定时器已启动。');
                },
                stopUiUpdates() {
                    if (this.uiUpdateInterval) {
                        clearInterval(this.uiUpdateInterval);
                        this.uiUpdateInterval = null;
                        console.log('UI 更新定时器已停止。');
                    }
                },

                // --- 核心检测逻辑 ---
                checkAllInterfaces() {
                    // Guard: Don't run if offline or no interfaces
                    if (!this.isOnline || this.interfaces.length === 0) {
                        if (!this.isOnline) console.log("Skipping checkAllInterfaces: Offline.");
                        return;
                    }
                    this.interfaces.forEach(iface => {
                        // Only check if the interface is not already marked as offline
                        if (iface.status !== 'offline') {
                            this.checkInterfaceStatus(iface.title);
                        } else {
                            console.log(`Skipping check for ${iface.title}: Marked as offline.`);
                        }
                    });
                },
                async checkInterfaceStatus(interfaceTitle) {
                    // Guard: Don't run if offline
                    if (!this.isOnline) {
                        console.log(`Skipping check for ${interfaceTitle}: Offline.`);
                        // Ensure status reflects offline if it somehow changed
                        this.updateInterfaceState(interfaceTitle, { status: 'offline', lastError: '网络已断开' });
                        return;
                    }

                    const ifaceIndex = this.interfaces.findIndex(i => i.title === interfaceTitle);
                    if (ifaceIndex === -1) {
                        console.warn(`checkInterfaceStatus: 未找到接口 Title '${interfaceTitle}'。`);
                        return;
                    }
                    let iface = this.interfaces[ifaceIndex];

                    // Don't check if already marked as offline (double check)
                    if (iface.status === 'offline') return;

                    this.updateInterfaceState(interfaceTitle, { status: 'pending', lastError: null, nextCheckInSeconds: undefined });

                    const controller = new AbortController();
                    const timeoutValue = (typeof iface.timeout === 'number' && iface.timeout > 0) ? iface.timeout : 3;
                    const timeoutMs = timeoutValue * 1000;
                    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

                    const startTime = Date.now();
                    let statusData = {
                        statusCode: null, responseTime: null, containsExpected: false,
                        success: false, error: null, timestamp: Date.now()
                    };
                    let finalState = {};

                    try {
                        const response = await fetchThroughProxy({
                            url: iface.url,
                            method: 'GET',
                            headers: { 'Cache-Control': 'no-cache' },
                            signal: controller.signal
                        });

                        clearTimeout(timeoutId);
                        const endTime = Date.now();
                        statusData.responseTime = endTime - startTime;
                        statusData.statusCode = response.status;

                        if (response.ok) {
                            const text = await response.text();
                            const expected = typeof iface.expectedText === 'string' ? iface.expectedText : '';
                            statusData.containsExpected = text.includes(expected);

                            if (statusData.containsExpected) {
                                statusData.success = true;
                                finalState = { status: 'ok', lastChecked: statusData.timestamp, lastResponseTime: statusData.responseTime, lastError: null };
                            } else {
                                statusData.success = false;
                                statusData.error = '响应未包含预期字符';
                                finalState = { status: 'error', lastChecked: statusData.timestamp, lastResponseTime: statusData.responseTime, lastError: statusData.error };
                                this.addToast(`"${iface.title}": ${statusData.error}`, 'warning');
                            }
                        } else {
                            statusData.success = false;
                            statusData.error = `HTTP 状态码: ${response.status}`;
                            try {
                                const errorText = await response.text();
                                if (errorText) statusData.error += ` - ${errorText.substring(0, 100)}`;
                            } catch (_) { /* Ignore */ }
                            finalState = { status: 'error', lastChecked: statusData.timestamp, lastResponseTime: statusData.responseTime, lastError: statusData.error };
                            this.addToast(`"${iface.title}": ${statusData.error}`, 'error');
                        }
                    } catch (error) {
                        clearTimeout(timeoutId);
                        const endTime = Date.now();
                        statusData.responseTime = endTime - startTime;
                        statusData.success = false;

                        // Check again if we went offline during the fetch
                        if (!this.isOnline) {
                            console.warn(`Request for ${iface.title} failed likely due to going offline.`);
                            statusData.error = '网络连接丢失';
                            finalState = { status: 'offline', lastChecked: statusData.timestamp, lastResponseTime: null, lastError: statusData.error };
                            // Don't toast here, global offline toast is sufficient
                        } else if (error.name === 'AbortError') {
                            statusData.error = `请求超时 (${timeoutMs / 1000}s)`;
                            finalState = { status: 'error', lastChecked: statusData.timestamp, lastResponseTime: null, lastError: statusData.error };
                            this.addToast(`"${iface.title}": ${statusData.error}`, 'error');
                        } else {
                            statusData.error = `请求失败: ${error.message}`;
                            finalState = { status: 'error', lastChecked: statusData.timestamp, lastResponseTime: null, lastError: statusData.error };
                            console.error(`代理请求错误 for ${iface.url}:`, error);
                            this.addToast(`"${iface.title}": ${statusData.error}`, 'error');
                        }
                    } finally {
                        // If we are now offline, force the state to offline regardless of fetch outcome
                        if (!this.isOnline) {
                            finalState.status = 'offline';
                            finalState.lastError = finalState.lastError || '网络已断开';
                        }
                        this.updateInterfaceState(interfaceTitle, finalState);

                        // Only log if not forced to offline state due to network loss
                        if (finalState.status !== 'offline') {
                            this.addLog({
                                id: crypto.randomUUID(),
                                interfaceTitle: interfaceTitle,
                                timestamp: statusData.timestamp,
                                url: iface.url,
                                statusCode: statusData.statusCode,
                                responseTime: statusData.responseTime,
                                containsExpected: statusData.containsExpected,
                                success: statusData.success,
                                error: statusData.error
                            });
                        }
                        if (this.isOnline) this.updateNextCheckTimers(); // Update timer only if online
                    }
                },

                // --- 接口操作 (CRUD - 基本不变, 添加时考虑在线状态) ---
                addInterface() {
                    // 从表单模型获取并清理数据
                    const title = this.newInterface.title.trim();
                    const url = this.newInterface.url.trim();
                    const expectedText = typeof this.newInterface.expectedText === 'string' ? this.newInterface.expectedText : '';
                    let timeout = parseInt(this.newInterface.timeout, 10);
                    if (isNaN(timeout) || timeout <= 0) timeout = 3; // 默认超时 3 秒

                    // 基本验证
                    if (!title || !url) {
                        this.addToast('请填写接口标题和 URL!', 'warning'); return;
                    }
                    try {
                        new URL(url); if (!url.match(/^https?:\/\//i)) throw new Error("无效协议");
                    } catch (e) {
                        this.addToast('URL 格式不正确 (需包含 http:// 或 https://)!', 'error'); return;
                    }
                    if (this.interfaces.some(iface => iface.title === title)) {
                        this.addToast(`已存在标题为 "${title}" 的接口! 请使用唯一标题。`, 'error'); return;
                    }

                    const newIface = {
                        title: title, url: url, expectedText: expectedText, timeout: timeout,
                        favicon: this.getFaviconUrl(url),
                        // Set initial status based on current network state
                        status: this.isOnline ? 'pending' : 'offline',
                        lastError: this.isOnline ? null : '网络已断开',
                        lastChecked: null, lastResponseTime: null, nextCheckInSeconds: undefined
                    };

                    this.interfaces.push(newIface);
                    this.saveInterfaces();
                    this.closeAddModal();
                    this.resetNewInterfaceForm();
                    this.addToast(`接口 "${title}" 已添加`, 'success');

                    // Check immediately only if online
                    if (this.isOnline) {
                        this.checkInterfaceStatus(newIface.title);
                        // Start polling if this is the first interface and online
                        if (this.interfaces.length === 1 && !this.pollingInterval) {
                            this.startPolling(); this.startUiUpdates();
                        }
                    }
                },
                openEditModal(iface) {
                    this.editingInterface = JSON.parse(JSON.stringify(iface));
                    if (typeof this.editingInterface.timeout !== 'number' || this.editingInterface.timeout <= 0) {
                        this.editingInterface.timeout = 3;
                    }
                    this.$refs?.editModal?.showModal();
                    this.$nextTick(() => this.$refs?.editModal?.querySelector('input[x-model="editingInterface.url"]')?.focus());
                },
                closeEditModal() {
                    if (this.$refs?.editModal?.open) this.$refs.editModal.close();
                    this.editingInterface = null;
                },
                updateInterface() {
                    if (!this.editingInterface) return;
                    const title = this.editingInterface.title;
                    const url = this.editingInterface.url.trim();
                    const expectedText = typeof this.editingInterface.expectedText === 'string' ? this.editingInterface.expectedText : '';
                    let timeout = parseInt(this.editingInterface.timeout, 10);
                    if (isNaN(timeout) || timeout <= 0) timeout = 3;

                    if (!url) { this.addToast('请填写接口 URL!', 'warning'); return; }
                    try { new URL(url); if (!url.match(/^https?:\/\//i)) throw new Error("无效协议"); }
                    catch (e) { this.addToast('URL 格式不正确!', 'error'); return; }

                    const index = this.interfaces.findIndex(i => i.title === title);
                    if (index !== -1) {
                        const wasOffline = this.interfaces[index].status === 'offline';
                        this.interfaces[index] = {
                            ...this.interfaces[index], // Preserve existing state (like lastChecked etc.)
                            url, expectedText, timeout,
                            favicon: this.getFaviconUrl(url),
                            // If currently online AND the status was 'offline', reset to 'pending' for immediate check
                            status: (this.isOnline && wasOffline) ? 'pending' : this.interfaces[index].status,
                            lastError: (this.isOnline && wasOffline) ? null : this.interfaces[index].lastError,
                        };
                        this.saveInterfaces();
                        this.closeEditModal();
                        this.addToast(`接口 "${title}" 已更新`, 'success');
                        // Trigger check only if online
                        if (this.isOnline) {
                            this.checkInterfaceStatus(title);
                        }
                    } else {
                        this.addToast(`更新失败：未找到接口 "${title}"`, 'error');
                        this.closeEditModal();
                    }
                },
                confirmDeleteInterface(title) {
                    const iface = this.interfaces.find(i => i.title === title);
                    if (!iface) return;
                    Swal.fire({
                        title: `确认删除接口 "${title}"?`, text: "将同时删除所有相关日志记录，此操作不可恢复!",
                        icon: 'warning', showCancelButton: true, confirmButtonColor: '#d33', cancelButtonColor: '#3085d6',
                        confirmButtonText: '确认删除', cancelButtonText: '取消'
                    }).then((result) => { if (result.isConfirmed) { this.deleteInterface(title); } });
                },
                async deleteInterface(title) {
                    this.interfaces = this.interfaces.filter(i => i.title !== title);
                    this.logs = this.logs.filter(log => log.interfaceTitle !== title);
                    try {
                        await this.db.deleteItem(this.INTERFACE_STORE_NAME, title);
                        await this.db.deleteLogsByInterfaceTitle(title);
                        console.log(`接口 '${title}' 及其日志已从数据库删除。`);
                        this.addToast(`接口 "${title}" 已删除`, 'success');
                        if (this.interfaces.length === 0) {
                            this.stopPolling(); this.stopUiUpdates();
                        }
                    } catch (error) {
                        console.error(`数据库删除接口/日志错误 (Title: ${title}):`, error);
                        this.addToast('删除接口或日志时出错，请刷新页面重试。', 'error');
                    }
                },
                updateInterfaceState(title, newState) {
                    const index = this.interfaces.findIndex(i => i.title === title);
                    if (index !== -1) {
                        // If going offline, force status to 'offline'
                        if (!this.isOnline) {
                            newState.status = 'offline';
                            newState.lastError = newState.lastError || '网络已断开';
                        }
                        this.interfaces[index] = { ...this.interfaces[index], ...newState };
                    } else {
                        console.warn(`updateInterfaceState: 未找到接口 Title '${title}'。`);
                    }
                },

                // --- 日志管理 (不变) ---
                async addLog(logData) {
                    if (!logData.interfaceTitle) { console.error("Attempted to add log without interfaceTitle:", logData); return; }
                    this.logs.push(logData);
                    const interfaceLogsInMemory = this.logs.filter(log => log.interfaceTitle === logData.interfaceTitle);
                    if (interfaceLogsInMemory.length > this.maxLogsPerInterface) {
                        interfaceLogsInMemory.sort((a, b) => b.timestamp - a.timestamp);
                        const logsToRemoveFromMemory = interfaceLogsInMemory.slice(this.maxLogsPerInterface);
                        const idsToRemove = new Set(logsToRemoveFromMemory.map(l => l.id));
                        this.logs = this.logs.filter(log => !idsToRemove.has(log.id));
                    }
                    try {
                        await this.db.saveLog(logData);
                        const prunedCount = await this.db.pruneOldLogs(logData.interfaceTitle, this.maxLogsPerInterface);
                        if (prunedCount > 0) { console.log(`为接口 ${logData.interfaceTitle} 从数据库清理了 ${prunedCount} 条旧日志。`); }
                    } catch (e) { console.error("后台日志保存/清理失败:", e); }
                },
                filteredLogs() {
                    if (!this.currentLogInterfaceTitle) return [];
                    return this.logs.filter(log => log.interfaceTitle === this.currentLogInterfaceTitle).sort((a, b) => b.timestamp - a.timestamp);
                },
                confirmClearLogs(interfaceTitle) {
                    const iface = this.interfaces.find(i => i.title === interfaceTitle);
                    if (!iface) return;
                    this.closeLogModal();
                    this.$nextTick(() => {
                        Swal.fire({
                            title: `确认清空接口 "${interfaceTitle}" 的所有日志?`, text: "此操作不可恢复!", icon: 'warning',
                            showCancelButton: true, confirmButtonColor: '#d33', cancelButtonColor: '#3085d6',
                            confirmButtonText: '确认清空', cancelButtonText: '取消',
                        }).then((result) => { if (result.isConfirmed) { this.clearLogs(interfaceTitle); } });
                    });
                },
                async clearLogs(interfaceTitle) {
                    const logsBefore = this.logs.filter(log => log.interfaceTitle === interfaceTitle).length;
                    this.logs = this.logs.filter(log => log.interfaceTitle !== interfaceTitle);
                    try {
                        const deletedCount = await this.db.deleteLogsByInterfaceTitle(interfaceTitle);
                        console.log(`已为接口 ${interfaceTitle} 清空 ${deletedCount} 条日志 (数据库)。`);
                        this.addToast(`已清空 ${logsBefore} 条日志`, 'success');
                    } catch (error) {
                        console.error(`数据库清空日志错误 (Title: ${interfaceTitle}):`, error);
                        this.addToast('清空数据库日志时出错。', 'error');
                    }
                },

                // --- IndexedDB 持久化接口列表 (不变) ---
                async saveInterfaces() {
                    try {
                        const dataToSave = JSON.parse(JSON.stringify(this.interfaces));
                        await Promise.all(dataToSave.map(iface => this.db.saveItem(this.INTERFACE_STORE_NAME, iface)));
                        console.log(`${dataToSave.length} 个接口已保存到 IndexedDB。`);
                    } catch (e) { console.error("保存接口列表到 IndexedDB 失败:", e); this.addToast('保存接口列表失败!', 'error'); }
                },


                // --- 接口配置导入/导出 (基本不变, 导入时考虑在线状态) ---
                exportConfig() {
                    console.log("正在导出接口配置...");
                    try {
                        const configOnly = this.interfaces.map(({ title, url, expectedText, timeout, favicon }) => ({ title, url, expectedText, timeout, favicon }));
                        const jsonString = JSON.stringify(configOnly, null, 2);
                        const blob = new Blob([jsonString], { type: 'application/json' });
                        const downloadUrl = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = downloadUrl;
                        a.download = `interface-monitor-config_${new Date().toISOString().slice(0, 10)}.json`;
                        document.body.appendChild(a); a.click(); document.body.removeChild(a);
                        URL.revokeObjectURL(downloadUrl);
                        this.addToast('接口配置已成功导出!', 'success');
                    } catch (error) { console.error("导出接口配置失败:", error); this.addToast('导出接口配置失败!', 'error'); }
                },
                importConfigTrigger() { this.$refs.fileInput.value = null; this.$refs.fileInput.click(); },
                handleFileDrop(event) {
                    this.isDraggingOver = false; event.preventDefault();
                    const files = event.dataTransfer.files;
                    if (files.length > 0) {
                        const file = files[0];
                        if (file.type === 'application/json' || file.name.endsWith('.json')) { this.processImportFile(file); }
                        else { this.addToast('请拖放有效的 JSON 文件 (.json)!', 'error'); }
                    }
                },
                handleFileImport(event) {
                    const file = event.target.files[0];
                    if (!file) { return; }
                    if (file.type !== 'application/json' && !file.name.endsWith('.json')) { this.addToast('请选择一个有效的 JSON 文件 (.json)!', 'error'); return; }
                    this.processImportFile(file);
                },
                openTextImportModal() {
                    this.importTextError = null; if (this.$refs.importTextArea) { this.$refs.importTextArea.value = ''; }
                    this.$refs?.textImportModal?.showModal();
                    this.$nextTick(() => this.$refs?.importTextArea?.focus());
                },
                closeTextImportModal() { this.importTextError = null; if (this.$refs?.textImportModal?.open) this.$refs.textImportModal.close(); },
                async handleTextInputImport() {
                    this.importTextError = null;
                    const jsonString = this.$refs.importTextArea.value.trim();
                    if (!jsonString) { this.importTextError = "请输入 JSON 配置内容."; return; }
                    try {
                        const importedData = JSON.parse(jsonString);
                        this.closeTextImportModal();
                        await this.processImportedData(importedData, false);
                    } catch (error) {
                        console.error("文本导入失败:", error);
                        this.importTextError = (error instanceof SyntaxError) ? `JSON 解析错误: ${error.message}` : `导入处理失败: ${error.message}`;
                    }
                },
                async importFromUrl(urlToFetch) {
                    if (!urlToFetch) return;
                    this.addToast(`正在从 URL 导入: ${this.truncateUrl(urlToFetch, 50)}...`, 'info');
                    try {
                        const response = await fetchThroughProxy({ url: urlToFetch });
                        if (!response.ok) throw new Error(`获取 URL 失败: HTTP ${response.status}`);
                        const contentType = response.headers.get("content-type");
                        if (!contentType || !contentType.includes("application/json")) { console.warn(`期望从 URL 获取 JSON，但 Content-Type 为: ${contentType}`); }
                        const importedData = await response.json();
                        await this.processImportedData(importedData, true); // Skip confirmation for URL import
                    } catch (error) { console.error(`从 URL ${urlToFetch} 导入时出错:`, error); throw new Error(`无法从 URL [${this.truncateUrl(urlToFetch, 30)}] 导入: ${error.message}`); }
                },
                processImportFile(file) {
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const importedData = JSON.parse(e.target.result);
                            await this.processImportedData(importedData, false); // Needs confirmation
                        } catch (error) {
                            console.error("文件导入失败:", error);
                            let errorMsg = (error instanceof SyntaxError) ? '导入失败: 文件不是有效的 JSON 格式。' : `导入失败: ${error.message}`;
                            this.addToast(errorMsg, 'error', 6000);
                        }
                    };
                    reader.onerror = (e) => { console.error("文件读取错误:", e); this.addToast('读取文件时出错!', 'error'); };
                    reader.readAsText(file);
                },
                async processImportedData(importedData, skipConfirmation = false) {
                    console.log(`处理导入的数据 (使用 Title 作为 key)。跳过确认: ${skipConfirmation}`);
                    let addedCount = 0; let updatedCount = 0; let skippedCount = 0;

                    try {
                        if (!Array.isArray(importedData)) { throw new Error("导入的数据必须是一个有效的 JSON 数组。"); }
                        const validatedInterfaces = [];
                        const importedTitles = new Set();

                        for (const item of importedData) {
                            if (typeof item !== 'object' || item === null) { skippedCount++; continue; }
                            if (typeof item.title !== 'string' || !item.title.trim()) { skippedCount++; continue; }
                            const trimmedTitle = item.title.trim();
                            if (importedTitles.has(trimmedTitle)) { skippedCount++; continue; }
                            if (typeof item.url !== 'string' || !item.url.trim()) { skippedCount++; continue; }
                            const trimmedUrl = item.url.trim();
                            try { new URL(trimmedUrl); if (!trimmedUrl.match(/^https?:\/\//i)) throw new Error("无效协议"); }
                            catch { skippedCount++; continue; }
                            if (typeof item.expectedText !== 'string') { skippedCount++; continue; }

                            importedTitles.add(trimmedTitle);
                            validatedInterfaces.push({
                                title: trimmedTitle, url: trimmedUrl, expectedText: item.expectedText,
                                timeout: (typeof item.timeout === 'number' && item.timeout > 0) ? item.timeout : 3,
                                favicon: item.favicon || this.getFaviconUrl(trimmedUrl),
                            });
                        }

                        if (validatedInterfaces.length === 0) { let message = "未找到有效的接口配置。"; if (skippedCount > 0) message += ` (${skippedCount} 个项目被跳过)`; this.addToast(message, 'warning'); return; }

                        const interfacesToAdd = []; const interfacesToUpdate = [];
                        const existingTitles = new Set(this.interfaces.map(iface => iface.title));

                        for (const newItem of validatedInterfaces) {
                            if (existingTitles.has(newItem.title)) {
                                const originalInterface = this.interfaces.find(i => i.title === newItem.title);
                                const wasOffline = originalInterface.status === 'offline';
                                const updatedItem = {
                                    ...originalInterface, url: newItem.url, expectedText: newItem.expectedText,
                                    timeout: newItem.timeout, favicon: newItem.favicon,
                                    // Reset status if online and was previously offline
                                    status: (this.isOnline && wasOffline) ? 'pending' : originalInterface.status,
                                    lastError: (this.isOnline && wasOffline) ? null : originalInterface.lastError,
                                };
                                interfacesToUpdate.push(updatedItem); updatedCount++;
                            } else {
                                const newItemWithState = {
                                    ...newItem,
                                    // Set initial status based on network
                                    status: this.isOnline ? 'pending' : 'offline',
                                    lastError: this.isOnline ? null : '网络已断开',
                                    lastChecked: null, lastResponseTime: null, nextCheckInSeconds: undefined
                                };
                                interfacesToAdd.push(newItemWithState); addedCount++;
                            }
                        }

                        if (addedCount === 0 && updatedCount === 0) { let message = '没有需要新增或更新的接口。'; if (skippedCount > 0) message += ` (${skippedCount} 个无效项目被跳过)`; this.addToast(message, 'info'); return; }

                        let confirmText = ""; if (updatedCount > 0) confirmText += `将更新 ${updatedCount} 个同名接口。\n`; if (addedCount > 0) confirmText += `将新增 ${addedCount} 个接口。\n`; if (skippedCount > 0) confirmText += `(${skippedCount} 个无效或重复项目被跳过)。\n`; confirmText += "\n是否继续？";
                        let isConfirmed = skipConfirmation;
                        if (!skipConfirmation) {
                            const result = await Swal.fire({ title: '确认导入?', html: confirmText.replace(/\n/g, '<br>'), icon: 'info', showCancelButton: true, confirmButtonColor: '#3085d6', cancelButtonColor: '#d33', confirmButtonText: '确认操作', cancelButtonText: '取消' });
                            isConfirmed = result.isConfirmed;
                        }

                        if (isConfirmed) {
                            // Temporarily stop polling if it's running
                            const wasPolling = !!this.pollingInterval;
                            if (wasPolling) { this.stopPolling(); this.stopUiUpdates(); }

                            try {
                                // Update memory
                                interfacesToUpdate.forEach(updatedItem => { const index = this.interfaces.findIndex(i => i.title === updatedItem.title); if (index !== -1) this.interfaces[index] = updatedItem; });
                                this.interfaces.push(...interfacesToAdd);

                                // Save to DB
                                const itemsToSave = [...interfacesToUpdate, ...interfacesToAdd];
                                await Promise.all(itemsToSave.map(iface => this.db.saveItem(this.INTERFACE_STORE_NAME, JSON.parse(JSON.stringify(iface)))));

                                let successMsg = ""; if (updatedCount > 0) successMsg += `成功更新 ${updatedCount} 个接口。`; if (addedCount > 0) successMsg += `${updatedCount > 0 ? ' ' : ''}成功新增 ${addedCount} 个接口。`;
                                this.addToast(successMsg, 'success');
                                console.log("合并导入成功。");

                                // Trigger checks only if online
                                if (this.isOnline) {
                                    this.$nextTick(() => itemsToSave.forEach(iface => this.checkInterfaceStatus(iface.title)));
                                }

                            } catch (dbError) {
                                console.error("将合并后的接口保存到 DB 时出错:", dbError);
                                this.addToast('合并导入接口时数据库操作失败!', 'error'); throw dbError;
                            } finally {
                                // Restart polling only if it was running before AND we are online
                                if (wasPolling && this.isOnline) { this.startPolling(); this.startUiUpdates(); }
                                else if (!this.isOnline) { console.log("Import complete, but remaining offline."); }
                            }
                        } else {
                            console.log("合并导入已取消。"); if (!skipConfirmation) this.addToast('导入操作已取消。', 'info');
                        }
                    } catch (processingError) { console.error("处理导入数据时出错:", processingError); throw processingError; }
                },


                // --- UI 与辅助函数 ---
                resetNewInterfaceForm() { this.newInterface = { title: '', url: '', expectedText: '', timeout: 3 }; },
                openAddModal() {
                    this.resetNewInterfaceForm(); this.$refs?.addModal?.showModal();
                    this.$nextTick(() => this.$refs?.addModal?.querySelector('input[type="text"]')?.focus());
                },
                closeAddModal() { if (this.$refs?.addModal?.open) this.$refs.addModal.close(); },
                openLogModal(title) { this.currentLogInterfaceTitle = title; this.$refs?.logModal?.showModal(); },
                closeLogModal() { if (this.$refs?.logModal?.open) this.$refs.logModal.close(); this.currentLogInterfaceTitle = null; },
                getFaviconUrl(baseUrl) {
                    try { const url = new URL(baseUrl); return `${url.protocol}//${url.hostname}/favicon.ico`; }
                    catch (e) { return DEFAULT_FAVICON_URI; }
                },
                // Updated getStatusText to include 'offline'
                getStatusText(status) {
                    return { ok: '正常', error: '异常', pending: '检测中...', offline: '离线 (暂停)' }[status] || '待检测';
                },
                formatTimestamp(timestamp) {
                    if (!timestamp) return 'N/A';
                    try { return new Date(timestamp).toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false }).replace(/\//g, '-'); }
                    catch (e) { return '无效日期'; }
                },
                truncateUrl(url, length = 40) {
                    if (!url) return '';
                    try { const parsed = new URL(url); let displayUrl = parsed.hostname + parsed.pathname + parsed.search + parsed.hash; if (displayUrl.endsWith('/')) displayUrl = displayUrl.slice(0, -1); return displayUrl.length > length ? displayUrl.substring(0, length) + '...' : displayUrl; }
                    catch { return url.length > length ? url.substring(0, length) + '...' : url; }
                },
                getInterfaceExpectedText(title) {
                    const iface = this.interfaces.find(i => i.title === title); return iface ? (iface.expectedText === '' ? '(空)' : iface.expectedText) : 'N/A';
                },
                // Update timer only if online
                updateNextCheckTimers() {
                    if (!this.isOnline) return; // Don't update timers if offline

                    const now = Date.now();
                    this.interfaces = this.interfaces.map(iface => {
                        let nextCheckInSeconds = undefined;
                        // Only calculate if not pending or offline
                        if (iface.lastChecked && iface.status !== 'pending' && iface.status !== 'offline') {
                            const remaining = this.pollingFrequency - (now - iface.lastChecked);
                            nextCheckInSeconds = Math.max(0, Math.round(remaining / 1000));
                        }
                        // Only update if value changed OR if status just became non-offline/non-pending
                        const needsUpdate = iface.nextCheckInSeconds !== nextCheckInSeconds;

                        if (needsUpdate) {
                            return { ...iface, nextCheckInSeconds };
                        }
                        return iface;
                    });
                },

                // --- Toast 通知 ---
                addToast(message, type = 'info', duration = 4000) {
                    const id = crypto.randomUUID();
                    this.toasts.push({ id, message, type });
                    setTimeout(() => this.removeToast(id), duration);
                },
                removeToast(id) { this.toasts = this.toasts.filter(t => t.id !== id); },

            } // appState return
        } // appState function
    </script>

</body>

</html>